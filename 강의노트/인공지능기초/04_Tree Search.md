## Tree Search

### 김성영교수

### 국립금오공과대학교

### 컴퓨터공학부

※본자료는국립금오공과대학교컴퓨터공학부황준하교수님의자료를참조및수정한것임


## Contents

### ⚫Introduction

### ⚫Uninformed Search

```
Breadth-first Search
Uniform Cost Search
Depth-first Search
Depth-limited Search
Iterative Deepening Search
```
### ⚫Informed Search

```
Greedy Best-first Search
A* Search
```

# Introduction


## Tree 탐색이란?

### ⚫탐색문제의 문제 정의는 초기 상태와 목표 상태를 포함한 상태를 정의

### ⚫상태 공간 상에서 탐색 tree를 만들어가는 과정

```
상태공간(state space): 모든 상태(초기상태, 목표 상태 등)들을 포함하고있는공간
Root 노드: 초기 상태
```
- 연산자를적용하여 현재상태를확장(expanding)하여새로운상태노드들생성
목표상태가 나올 때까지반복적으로수행 → 하나의해도출

### ⚫어떤 노드를 먼저 펼칠 것인가? (=탐색 전략)

```
다양한tree 탐색알고리즘
depth-first 탐색, breadth-first 탐색 등
```

## Tree 탐색 이해를 위한 예제

### ⚫최단 경로 찾기 문제

##### A로부터출발하여M까지가는 최단 경로찾기

```
A
H
```
```
L
```
```
M
```
```
I
K
```
```
J N
```
```
D
E
```
```
F
G
```
```
B
```
```
C
```
```
O P
```
```
Q
```
```
R
```
```
S
```
```
T
```
```
140
118
```
```
75
```
```
71
```
```
99
211
```
```
111
70
75
120
```
```
146
```
```
97
```
```
138
```
```
101
```
```
90
```
```
85
```
```
87
92
```
```
142
```
```
98
86
```
```
151
```
```
80
```
```
초기상태
```
```
목표상태
```

## 최단 경로 찾기 문제를 위한 tree 탐색 과정

```
(a) 초기상태 A
```
```
A
```
```
B D H
```
```
(b) 상태A 확장후
```
```
A
```
```
B D H
```
```
(c) 상태B확장후
```
```
A C
```
```
어떤상태부터
확장할까?
```
```
실제 적용시에는 이미등장
했던 상태는제외(무한 반복
방문 회피)
```
```
노드 확장(expanding)
```
```
어떤 노드를확장?
다양한 tree탐색 알고리즘이 가능
```

## 일반적인 tree 탐색 알고리즘 (1)

### ⚫노드: tree 구성을 위한 상태를 포함한 정보들

```
상태(state) : 현재 상태
부모노드(parent node) : 부모 노드를통해 초기 노드까지추적
연산자(operator) : 부모 상태에서현재 상태로의이동 연산자
깊이(depth) : tree 상에서의깊이로 root 노드의 깊이는 0
경로비용(path cost) : 초기 상태로부터현재 상태까지의비용합
```
### ⚫fringe (=frontier)

##### 노드들이확장 전에 저장되는공간

```
확장을위해 선택된노드는 fringe에서 제거
Depth-first 탐색: 스택으로구현
Breadth-first 탐색: 큐로 구현
```
```
노드
```
```
노드 노드 노드
```
```
노드
```
```
B
상태
```
```
부모노드
```
```
연산자깊이: 1: B
경로비용: 75 C
연산자깊이: 2: C
경로비용: 146
```
```
A 연산자: A
깊이: 0
경로비용: 0
```

## 일반적인 Tree 탐색 알고리즘 (2)

일반적인 Tree 탐색알고리즘

```
부모NULL, 연산자NULL, 깊이0, 경로비용 0
```

## Tree 탐색 알고리즘의 성능 평가

#### ⚫해의 도출 여부(completeness)

```
하나의해를 찾을 수있다는보장이 있는가?
```
#### ⚫최적해 도출 여부(optimality)

```
반환하는 해가 최적해임을보장하는가?
```
#### ⚫시간 복잡도(time complexity)

```
하나의해를 찾는 데최악의경우 얼마나많은 시간이소요되는가?
= 하나의해를 찾는 데최악의경우 확장되는 노드의수가 몇개인가?
```
#### ⚫공간 복잡도(space complexity)

```
하나의해를 찾는 데최악의경우 얼마나많은 메모리를 필요로하는가?
```
- 어떤한순간에 필요로하는가장많은메모리의크기는?
- 하나의해를찾기까지총1,000개의 노드가확장된다 하더라도어떤순간에최대로 저장해야되는노드의수가 100 개
    라면공간복잡도는 O(100)이됨


## Tree 탐색 알고리즘의 분류

### ⚫Uninformed Search (= Blind Search)

##### 확장노드 선택: 초기 상태부터현재 상태까지의경로 정보만사용

```
Breadth-first Search, Uniform Cost Search, Depth-first Search,
Depth-limited Search, Iterative Deepening Search
```
### ⚫Informed Search (= Heuristic Search)

##### 현재상태부터목표 상태까지의경로 정보 사용 (어떻게?)

- 추정치활용
- 최단경로찾기문제: 상태A로부터상태B, D, H 중어떤것부터확장할것인가?
Greedy Best-first Search, A* Search


# Uninformed Search


## 너비 우선 탐색 (Breadth-first Search)

### ⚫너비 우선 탐색의 노드 확장 순서

```
깊이가얕은 노드부터확장, Queue로 구현 가능
예: 9번노드가목표 상태라면?
```
- 1, 2, 3, 4, 5, 6, 7, 8, 9

```
1
```
```
2 3 4
```
```
5 6 9 10 11
```
```
깊이 : 0
```
```
깊이 : 1
```
```
깊이 : 2
```
```
깊이 : 3^1718
```
```
7 8
```
```
12 13 14 15 16 19 20 21 22 23
```

```
13
```
## 너비 우선 탐색 : 최단 경로 찾기 문제 적용

### ⚫최단 경로 찾기 문제에 적용한 결과

##### 가정: 이미지나온 상태이동 X

##### 상태확장 순서

- A, B, D, H, C, E, C, I, L, H, F, B, J, K, M
최종해: A, H, L, M →최적해? A

```
B D H
```
```
C E C I L
```
```
H F B J K M
```
```
I L G G K J M
```
```
깊이: 0
```
```
깊이: 1
```
```
깊이: 2
```
```
깊이: 3
```
```
깊이: 4
```
```
1
```
(^234)
5
10
6
11
7 8 9
(^12131415)
A
H L
M
I
K
J N
D
E
F
G
B
C
O P
Q
R
T S
140
118
75
71
99
211
111
70
(^75120)
146
97
138
101
90
85
87
92
142
(^9886)
151
80
초기상태
목표상태
12(B) : dead end(막다른 길)
더이상 갈곳이 없음


## 너비 우선 탐색 : 성능 평가 (1)

#### ⚫해의 도출 여부 : O

```
시간이충분하다면 해의 도출보장
```
#### ⚫최적해의 도출 여부 : 

```
깊이 기준최적해 O
거리 기준최적해 X
```
#### ⚫시간 복잡도 : O(bd)

```
확장 노드의개수 =
```
- 평균적으로확장되어 나오는노드의 개수(branching factor) : b
- 해가있는깊이: d

#### ⚫공간 복잡도 : O(bd)

```
모든 노드를저장하고 있어야노드 확장 가능
```

## 너비 우선 탐색 : 성능 평가 (2)

### ⚫해가 존재하는 깊이에 따른 소요 시간 및 메모리

```
branching factor : 10
하나의노드 평가 시간: 1밀리초(ms)
하나의노드 메모리: 100byte
```
### ⚫[프로그램 2.1] 최단 경로 찾기 문제를 위한 너비 우선 탐색

```
깊이 확장 노드수 소요 시간 소요메모리
0 1 1 밀리초 100 B
2 111( 102 ) 1 초 10 KB
```
(^4) 11,111( 104 ) 11 초 1 MB
6 106 18 분 100 MB
8 108 31 시간 10 GB
10 1010 128 일 1 TB
12 1012 35 년 100 TB
14 1014 3500 년 10 PB


## 균일 비용 탐색 (Uniform Cost Search)

### ⚫경로 비용이 가장 적은 노드를 먼저 확장

##### 경로비용 측면에서최적해의도출보장

- 단, 노드n의비용값(g(n)) < n 노드확장이후의경로비용값(g(operator(n)))
    ▪실세계문제대부분은이 조건을만족: 최단경로찾기문제등

### ⚫최단 경로 찾기 문제 적용 결과 A

```
B D H
```
```
C E C I L
```
```
H F B J K M
```
```
I L G G K J M
```
```
깊이: 0
```
```
깊이: 1
```
```
깊이: 2
```
```
깊이: 3
```
```
깊이: 4
```
```
1
```
(^234)
5
10
7
11
9 6 8
(^131412)
75
0
118 140
146 229 291 220 239
(^297299362366317450)
(^37739615374486504455418)
J^494
16
깊이: 5
17
J 523 K 474 M^606
18
A H L
M
I K
J N
D
E
F
G
B
C
O P
Q
R
T S
140
118
75
71
99
211
111
70
(^75120)
146
97
138
101
90
85
87
92
142
(^9886)
151
80
초기상태
목표상태


## 균일 비용 탐색 : 성능 평가

#### ⚫해의 도출 여부 : O

```
시간이충분하다면 해의 도출보장
```
#### ⚫최적해의 도출 여부 : O

```
거리 기준최적해 O
깊이 기준최적해 X
```
#### ⚫시간 복잡도 : O(bd)

```
확장 노드의개수 =
```
- 평균적으로확장되어 나오는노드의 개수(branching factor) : b
- 해가있는깊이: d

#### ⚫공간 복잡도 : O(bd)

```
모든 노드를저장하고 있어야노드 확장 가능
```
#### ⚫[프로그램2.2] 최단 경로 찾기 문제를 위한균일 비용 탐색


## 깊이 우선 탐색 (Depth-first Search)

### ⚫깊이 우선 탐색의 노드 확장 순서

```
확장중인 노드의 자식노드부터확장, Stack으로 구현 가능
예: 12번노드가목표 상태라면?
```
- 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12

```
1
```
```
2 8 15
```
```
3 6 16 18 21
```
```
깊이 : 0
```
```
깊이 : 1
```
```
깊이 : 2
```
```
깊이 : 3^1314
```
```
9 12
```
```
4 5 7 10 11 17 19 20 22 23
```

## 깊이 우선 탐색 : 최단 경로 찾기 문제 적용

### ⚫상태 확장 순서 : A, B, C, H, I, J, G, F, E, D, K, M

### ⚫최종해 : A, B, C, H, I, J, K, M A

```
B D H
```
```
C
```
```
H
I L
```
```
깊이: 0
```
```
깊이: 1
깊이: 2
```
```
깊이: 3
```
```
깊이: 4
```
```
1
2
```
```
3
```
```
4
```
```
J K
```
```
5
```
```
6
```
(^7) G
...
(^11) K
깊이: 5
깊이: 6
...
깊이: (^78) F^12 M
A
H L
M
I
K
J N
D
E
F
G
B
C
O P
Q
R
T S
140
118
75
71
99
211
111
70
(^75120)
146
97
138
101
90
85
87
92
142
(^9886)
151
80
초기상태
목표상태


## 깊이 우선 탐색 : 성능 평가

#### ⚫해의 도출 여부 : X

```
알고리즘 설계 시주의 필요
최단 경로찾기 문제에서 지나온 경로상의 상태로다시 갈수있다고 가정한다? 무한 반복 상황발생 가능
```
#### ⚫최적해의 도출 여부 : X

```
거리 기준최적해 X
깊이 기준최적해 X
```
#### ⚫시간 복잡도 : O(bm)

```
m : 탐색 트리의최대 깊이
```
#### ⚫공간 복잡도 : O(bm)

```
한순간에는 해당 깊이로의 노드들만 저장하면 됨
```
- 이미지나간트리에는해가없다는 것을확인→저장필요없음

#### ⚫[프로그램2.3] 최단 경로 찾기 문제를 위한깊이 우선 탐색


## 깊이 제한 탐색 (Depth Limited Search)

### ⚫해 노드 k가 다음과 같이 위치할 경우

##### 깊이 2 까지만확장하면끝!

### ⚫깊이 3 까지 확장하는 것으로 제한한다면?

##### 깊이제한 탐색

```
1
2
3 k
```
```
깊이: 0
깊이: 1
깊이: 2
깊이: 3 4
```
```
깊이: n
```
```
..
.
1
2 8 15
3 6 16 18
```
```
깊이: 0
깊이: 1
깊이: 2
깊이: 3 13 14
```
```
9 12
4 5 7 10 11 17
```
```
깊이: n
```
```
..
.
```
```
depth limit을어떻게설정할
것인가?
```

## 깊이 제한 탐색 : 최단 경로 찾기 문제 적용

### ⚫depth limit = 4

### ⚫상태 확장 순서

##### A, B, C, H, I, L, D, E, F, G, H, C, B, I, J, G, K, K, J, M

### ⚫최종해 : A, H, I, K, M A

```
B D H
```
```
C E C I L
```
```
H F B J K
```
```
I L G G K J M
```
```
깊이: 0
```
```
깊이: 1
```
```
깊이: 2
```
```
깊이: 3
```
```
깊이: 4
```
```
1
```
(^2711)
3
4
8
9
12 14
13 15 18
(^561016171920)


## 깊이 제한 탐색 : 성능 평가

### ⚫해의 도출 여부 : O

```
단, depth limit을 해의깊이와 같거나크게 설정해야함
```
### ⚫최적해의 도출 여부 : X

##### 거리기준 최적해 X

##### 깊이기준 최적해 X

### ⚫시간 복잡도 : O(bl)

```
l: depth limit
```
### ⚫공간 복잡도 : O(bl)

##### 내부적으로깊이 우선탐색이 실행됨

### ⚫[프로그램 2.4] 최단 경로 찾기 문제를 위한 깊이 제한 탐색


## 반복적 깊이 증가 탐색 (Iterative Deepening Search)

### ⚫깊이 제한 탐색을 반복적으로 수행

```
depth limit 0, 1, 2, 3, 4, ...
```
- 깊이제한이증가할때마다
    이전트리모두삭제후다시수행
내부적으로깊이 우선탐색

```
깊이: 0^1
(a) 깊이제한= 0
2
3 4 5
```
```
깊이: 0
깊이: 1
(b) 깊이제한= 1
6
7 10 13
8 9 14 15 16
```
```
깊이: 0
깊이: 1
깊이: 2 11 12
(c) 깊이제한= 2
17
18 24 31
19 22 32 34 37
```
```
깊이: 0
깊이: 1
깊이: 2
깊이: 3^2930
```
```
25 28
20 21 23 26 27 33 35 36 38 39
(d) 깊이.제한= 3
..
```

## 반복적 깊이 증가 탐색 : 최단 경로 찾기 문제 적용

### ⚫상태 확장 순서

##### (A), (A, B, D, H), (A, B, C, D, E, H, C, I, L),

##### (A, B, C, H, D, E, F, H, C, B, I, J, K, L, M)

### ⚫최종해 : A, H, L, M

```
A
B D H
C E C I L
H F B J K
```
```
깊이: 0
깊이: 1
깊이: 2
깊이: 3
```
```
15
```
(^161922)
17
18
20
21
23 25
(^24262729) M
(d) 깊이제한= 3
A
B D H
C E C I L
깊이: 0
깊이: 1
깊이: 2
6
(^7911)
8 10 12 13
(c) 깊이제한= 2
14
28
A
B D H
깊이: 0
깊이: 1
2
(^345)
(b) 깊이제한= 1
깊이: 0^1 A
(a) 깊이제한= 0


## 반복적 깊이 증가 탐색 : 성능 평가 (1)

### ⚫해의 도출 여부 : O

##### 너비우선 탐색과 동일

### ⚫최적해의 도출 여부 : 

##### 너비우선 탐색과 동일

##### 깊이기준 최적해 O

##### 거리기준 최적해 X


## 반복적 깊이 증가 탐색 : 성능 평가 (2)

### ⚫시간 복잡도 : O(bl)

```
l: depth limit
이전depth limit의노드들모두 삭제 →시간 훨씬 많이소요?
```
- 깊이제한탐색과반복적깊이증가탐색의확장노드개수비교
- b= 10, l=5라면
    ▪깊이제한탐색: 111,111개
    ▪반복적깊이증가탐색: 123,456개(약10% 증가)

### ⚫공간 복잡도 : O(bl)

##### 내부적으로깊이 우선탐색이 실행됨

### ⚫[프로그램 2.5] 최단 경로 찾기 문제를 위한 반복적 깊이 증가 탐색


## Uninformed Search 알고리즘 요약 및 비교

```
b : branching factor
d : 해가 위치하는깊이
m: 탐색 트리의최대 깊이
l: 깊이 제한 탐색 시깊이제한
```

# Informed Search


## Informed Search : Introduction

### ⚫확장 노드 선택 순서 : f(n) 값이 가장 좋은(작은) 것부터

```
f(n) = g(n) + h(n)
```
- g(n): 초기상태부터현재상태n까지의정보
    ▪최단경로찾기문제: 실제이동거리
- h(n): 현재상태n부터목표상태까지의정보(휴리스틱)
    ▪최단경로찾기문제: 추정거리

### ⚫Uninformed Vs. Informed Search

```
Uninformed Search : h(n)= 0
Informed Search
```
- Greedy Best-first Search : g(n) = 0
- A* Search : g(n), h(n)모두사용

```
A
H L
```
```
M
```
```
I
K
```
```
J N
```
```
D
E
F
G
```
```
B
```
```
C
```
```
O P
Q
```
```
R
```
```
S
```
```
T
```
```
140
118
```
```
75
```
```
71
```
```
99
211
111
70
```
(^75120)
146
97
138
101
90
85
87
92
142
98
86
151
80
초기상태
목표상태


## Informed Search : 휴리스틱 함수 h(n) (1)

### ⚫h(n) : 노드 n에서 목표 노드까지의 최저 비용에 대한 추정 비용

```
예) 최단 경로 찾기 문제: 노드 n의도시에서목표도시까지의 최단거리에 대한추정 거리
```
- 가장좋은상황: 실제최단거리반영→ 그러나실제최단거리는알수없음
어떻게추정할것인가? → 문제에대한 지식 활용

### ⚫최단 경로 찾기 문제에서의 h(n)

##### A ~ M 거리(실제최단 거리 418):

- 0 으로추정? 100으로? 200으로? ok
- 500 으로추정? No!
    ▪과대평가(overestimate)해서는안됨
과대평가하지않으면서가능한 최단거리로 추정
- "직선거리" 사용가능

```
A
H L
```
```
M
```
```
I
K
```
```
J N
```
```
D
E
F
G
```
```
B
```
```
C
```
```
O P
Q
```
```
R
```
```
T S
```
```
140
118
```
```
75
```
```
71
```
```
99
211
111
70
```
(^75120)
146
97
138
101
90
85
87
92
142
98
86
151
80
초기상태
목표상태


## Informed Search : 휴리스틱 함수 h(n) (2)

### ⚫최단 경로 찾기 문제의 h(n)

##### 목표도시 M까지의직선 거리

```
A
H
```
```
L
```
```
M
```
```
I
K
```
```
J N
```
```
D
E
F
G
```
```
B
```
```
C
```
```
O P
Q
```
```
R
```
```
S
```
```
T
```
```
140
118
```
```
75
```
```
71
```
```
99
211
```
```
111
70
75
120
```
```
146
```
```
97
```
```
138
```
```
101
```
```
90
```
```
85
```
```
87
92
```
```
142
```
```
98
86
```
```
151
```
```
80
```
```
초기상태
```
```
목표상태
```
```
도시 h(n)
A 366
B 374
C 380
D 329
E 244
F 241
G 242
H 253
I 193
J 160
K 98
L 178
M 0
N 77
O 80
P 151
Q 161
R 199
S 226
T 234
```

## Greedy Best-first Search

### ⚫목표 상태와 가장 가까운 노드를 먼저 확장

```
f(n) = h(n)
```
### ⚫최단 경로 찾기 문제로의 적용

##### 노드확장 순서 : A, H, L, M

##### 최종해: A, H, L, M

```
A
```
```
B D H
```
```
C I L
```
```
깊이: 0
```
```
깊이: 1
```
```
깊이: 2
```
```
깊이: 3
```
```
1
```
```
2
```
```
3
```
```
4
```
```
374
```
```
366
```
```
329 253
```
```
380 193 178
```
```
M 0
```

## Greedy Best-first Search : 성능 평가

### ⚫해의 도출 여부 : O

##### 다만, 이미나왔던 상태에대한 제어가되지 않을경우 보장 X

- 예) 초기도시S, 목표도시C

### ⚫최적해의 도출 여부 : X

### ⚫시간 복잡도 : O(bm)

```
m : 탐색 트리의최대 깊이
dead end에서 백트랙상황 발생 가능
```
### ⚫공간 복잡도 : O(bm)

##### 탐색도중 언제 어떤 노드든확장 가능

### ⚫[프로그램 2.6] 최단 경로 찾기 문제를 위한 Greedy Best-first 탐색

```
A
H L
```
```
M
```
```
I
K
```
```
J N
```
```
D
E
F
G
```
```
B
```
```
C
```
```
O P
Q
```
```
R
```
```
S
```
```
T
```
```
140
118
```
```
75
```
```
71
```
```
99
211
111
70
```
(^75120)
146
97
138
101
90
85
87
92
142
98
86
151
80
초기상태
목표상태


## A* Search

### ⚫초기 상태부터 현재 상태까지의 정보, 현재 상태에서 목표 상태까지의 정보 모두 사용

```
f(n) = g(n) + h(n)
```
### ⚫최단 경로 찾기 문제로의 적용

##### 노드확장 순서 : A, H, I, K, L, M

##### 최종해: A, H, I, K, M

```
A
```
```
B D H
```
```
C I L
```
```
깊이: 0
```
```
깊이: 1
```
```
깊이: 2
```
```
깊이: 3
```
```
1
```
```
2
```
```
5
```
```
6
```
```
75+374
=44 9
```
```
0+366
=366
```
```
118+329
=44 7
```
```
140+253
=39 3
```
```
291+380
=67 1
```
```
220+193
=41 3
```
```
239+178
=41 7
```
```
450+0
J K M =450
366+160^4
=526 317+98=415
```
깊이: (^4) M 418+0 418
3
J 455+160=615


## A* Search : 성능 평가

### ⚫해의 도출 여부 : O

### ⚫최적해의 도출 여부 : O

```
단, h(n) : 과대평가되어서는안됨. 직선거리는 가능
h(n)이 항상 최단 거리로추정한다면?
```
- 탐색이필요없음. 최단경로로만 확장

### ⚫시간 복잡도 : O(bm)

```
m : 탐색 트리의최대 깊이
```
### ⚫공간 복잡도 : O(bm)

##### 탐색도중 언제 어떤 노드든확장 가능

### ⚫[프로그램 2.7] 최단 경로 찾기 문제를 위한 A* Search

```
최단경로찾기문제에서f 값이 418 이하인노드는모두확장됨.
결국 418 이하인노드가존재하지않으며최적해보장
```

## 휴리스틱 함수 h(n)의 중요성 (1)

#### ⚫최단 경로 찾기 문제 Vs. 8-puzzle 문제

#### ⚫ 8 - puzzle 문제의 휴리스틱 함수 h(n)

```
h1: 목표상태와 동일한위치에있지 않은 숫자 타일의개수
h2: 각숫자타일이 다른 숫자와관계없이 목표 상태에있는 자신 위치로이동하기 위한 최소 이동횟수 합
```
```
1 5
4 3 2
7 8 6
```
```
1 2 3
4 5 6
7 8
초기상태 목표상태
```

## 휴리스틱 함수 h(n)의 중요성 (2)

### ⚫h2 기준 노드 확장 순서

```
g(n) : 지금까지의공백 타일이동 횟수
```
```
깊이: 0
```
```
깊이: 1
```
```
깊이: 2
```
```
깊이: 3
```
```
1 1 5 0+7=7
4 3 2
7 8 6
```
```
2 1 5 1+6=7
4 3 2
7 8 6
```
```
1 5 1+8=9
4 3 2
7 8 6
```
```
1 3 5 1+6=7
4 2
7 8 6
```
```
3 1 5 2 2+5=7
4 3
7 8 6
```
```
4 1 5 2 3+4=7
4 3
7 8 6
```
```
1 5 2 3+4=7
4 3 6
7 8
```
```
1 5
4 3 2
7 8 6
```
```
1 2 3
4 5 6
7 8
초기상태 목표상태
```

## 휴리스틱 함수 h(n)의 중요성 (3)

### ⚫h1과 h2에 대한 실험 결과

##### 해당 깊이에최적해가

##### 있는 경우각각

##### 노드 확장개수


## 요약

#### ⚫트리 탐색은 초기 상태를 시작으로 목표 상태를 찾을 때까지 트리를 만드는 과정이며 노드 확장

#### (expand) 전략에 따라 다양한 탐색 기법이 가능

#### ⚫탐색 알고리즘의 성능 평가를 위해 해의 도출 여부, 최적해 도출 여부, 시간 복잡도, 공간 복잡

#### 도에 대한 확인 필요

#### ⚫트리 탐색은 uninformed search와 informed search로 구분

#### ⚫Uninformed search에는 breadth-first search, depth-first search, iterative

#### deepening search 등이 있음

#### ⚫Informed search의 하나인 A* search에서는 현재 노드까지의 평가값(g(n))뿐만 아니라 현재

#### 노드에서 목표 노드까지의 추정치(h(n))를 함께 사용

#### ⚫h(n)은 과대평가되어서는 안되며 실제 최적값과 가까울 수록 더 빨리 최적해를 찾을 수 있음


