주제/단락 | 내용
---|---
CPU는기억장치에 저장되어 명령어들을 | CPU는기억장치에 저장되어 명령어들을 인출하여 실행함으로
써실제적인 작업을수행 | 명령어사이클 (instruction cycle)
써실제적인 작업을수행 | CPU가한개의명령어를 실행하는 데필요한전체처리과정
써실제적인 작업을수행 | CPU가프로그램 실행을시작한순간부터 전원을끄거나회복불가능한 오류가
발생하여 중단될때까지반복 | 두개의부사이클 (sub-cycle)들로분리
인출사이클 (fetch cycle) | 인출사이클 (fetch cycle): CPU가기억장치로부터 명령어를 읽어오는 단계
실행사이클 (execution cycle) | 실행사이클 (execution cycle): 명령어를 해독하고 실행하는 단계
발생하여 중단될때까지반복 | 기본명령어사이클
발생하여 중단될때까지반복 | 프로그램 카운터 (Program Counter, PC)
발생하여 중단될때까지반복 | 다음에인출할명령어의 주소를가지고있는레지스터
발생하여 중단될때까지반복 | 명령어가 인출된후에는자동적으로 일정크기 (한명령어길이 )만큼증가
발생하여 중단될때까지반복 | 분기 (branch) 명령어가 실행되는 경우에는 목적지주소로갱신
발생하여 중단될때까지반복 | 누산기 (Accumulator, AC)
발생하여 중단될때까지반복 | 데이터를 일시적으로 저장하는 레지스터
발생하여 중단될때까지반복 | ALU의산술연산과논리연산과정에사용
발생하여 중단될때까지반복 | 레지스터의 길이는 CPU가한번에처리할수있는데이터비트수(단어길
이)와동일 | 명령어레지스터 (Instruction Register, IR)
이)와동일 | 가장최근에인출된명령어코드가저장되어 있는레지스터
이)와동일 | 제어장치는 IR에서명령어를 읽어와서해독하고 명령을수행하기 위해
컴퓨터의 각장치에제어신호 전송 | 기억장치 주소레지스터 (Memory Address Register, MAR)
컴퓨터의 각장치에제어신호 전송 | PC에저장된명령어주소가시스템주소버스로출력되기 전에일시적으
로저장되는 주소레지스터 | 기억장치 버퍼레지스터 (Memory Buffer Register, MBR)
로저장되는 주소레지스터 | 기억장치 데이터레지스터 (Memory Data Register, MDR) 라고도불림
로저장되는 주소레지스터 | 기억장치에 쓰여질데이터혹은기억장치로부터 읽혀진데이터를 일시적
으로저장하는 버퍼레지스터 | 데이터레지스터 (Data Register, 범용레지스터 )
으로저장하는 버퍼레지스터 | CPU내의데이터를 일시적으로 저장하기 위한레지스터
으로저장하는 버퍼레지스터 | 입출력주소레지스터 (I/O Address Register, I/O AR)
으로저장하는 버퍼레지스터 | 특정 I/O 장치의주소를지정하는 데사용
으로저장하는 버퍼레지스터 | 입출력버퍼레지스터 (I/O Buffer Register, I/O BR)
으로저장하는 버퍼레지스터 | I/O 모듈과 CPU 간에데이터를 교환하는 데사용
으로저장하는 버퍼레지스터 | 스택제어레지스터 (Stack Control Register, Stack Pointer, SP)
으로저장하는 버퍼레지스터 | 메모리의 한블록이며 , 데이터는 후입선출 (Last In -First Out, LIFO)
으로저장하는 버퍼레지스터 | 복귀할주소정보를저장
으로저장하는 버퍼레지스터 | 상태레지스터 (Status Register, SR)
으로저장하는 버퍼레지스터 | CPU가작동하는 동안특정조건발생을표시하는 데사용
으로저장하는 버퍼레지스터 | 1Byte또는 2Bytes인특수목적용레지스터
으로저장하는 버퍼레지스터 | 명령어실행결과에따른조건플래그 (condition flag) 들저장
으로저장하는 버퍼레지스터 | [예] 산술연산또는비교결과로모든비트가 0인제로 (zero)값이누산기 (AC)에
입력되면 ,제로플래그 (Z)를1로설정 | 플래그레지스터 (Flag Register, FR), 프로그램 상태워드 (Program Status
SZCEVIP | 조건플래그의 종류
부호 (S) 플래그 | 부호 (S) 플래그 : 직전에수행된산술연산 결과값의 부호비트를저장 (양수 : 0, 음수 : 1)
제로 (Z) 플래그 | 제로 (Z) 플래그 : 연산결과값이 0이면 , 1로세트
올림수 (C) 플래그 | 올림수 (C) 플래그 : 덧셈이나 뺄셈에서 올림수 (carry)나빌림수 (borrow)가
동등 (E) 플래그 | 동등 (E) 플래그 : 두수를비교한결과가같게나왔을경우에 1로세트
오버플로우 (V) 플래그 | 오버플로우 (V) 플래그 : 산술연산과정에서 오버플로우가 발생한경우에 1
로세트 | 인터럽트 (I) 플래그
로세트 | 인터럽트 가능 (interrupt enabled) 상태이면 , 0으로세트
로세트 | 인터럽트 불가능 (interrupt disabled) 상태이면 , 1로세트
로세트 | 슈퍼바이저 (P) 플래그
로세트 | CPU의실행모드가슈퍼바이저 (커널 )모드 (supervisor mode) 이면 , 1로세트
로세트 | 사용자모드 (user mode) 이면 , 0으로세트
로세트 | 클럭 (Clock)
로세트 | CPU를비롯한컴퓨터의 모든부품이일정한속도로작동하기 위한전기적
진동 (pulse) | 클럭발생기가 만들며 , 일반적으로 클럭수가클수록컴퓨터의 처리속도가빠름
진동 (pulse) | 클럭주파수 (Hz 단위 )는1초에클럭이몇번발생하는지를 의미
진동 (pulse) | 1초에 1번클럭이발생하면 클럭주파수는 1Hz
진동 (pulse) | 1초에109번클럭이발생하면 클럭주파수는 1GHz
진동 (pulse) | 클럭주기는한신호뒤에서다음신호가올때까지의 간격
진동 (pulse) | 클럭주기 = 1
클럭주파수 | 마이크로 연산 (micro -operation)
클럭주파수 | CPU 클럭의각주기동안수행되는 기본단위의동작
클럭주파수 | 인출사이클의 마이크로 연산 t0: MAR ← PC t1: MBR ← M[MAR], PC ← PC + 1 t2: IR ← MBR
첫번째주기 (t0) | 첫번째주기 (t0): 현재의 PC가지정하는 명령어의 주소가 CPU 내부버스를
두번째주기 (t1) | 두번째주기 (t1): MAR에저장된명령어의 주소가기억장치로 이동되고 , 기
재하며 , PC의내용에 1을더함 | 만약 , 주소지정단위가 1Byte이고 , 명령어크기가 2Bytes인경우 , t1 에서 PC ←
세번째주기 (t2) | 세번째주기 (t2): MBR에있는명령어가 명령어레지스터인 IR로이동 t0: MAR ← PC t1: MBR ← M[MAR], PC ← PC + 1 t2: IR ← MBR
PC + 2로증가 | CPU는실행사이클동안에명령어코드를해독 (decode)하고 ,
그결과에따라필요한연산들을 수행 | CPU가수행하는 연산들의 종류
데이터이동 | 데이터이동 : CPU와기억장치 간혹은 I/O장치간에데이터를 이동
데이터처리 | 데이터처리 : 데이터에 대하여산술혹은논리연산을수행
데이터저장 | 데이터저장 : 연산결과 데이터혹은입력장치부터 읽어드린 데이터를 기억
프로그램 제어 | 프로그램 제어 : 프로그램의 실행순서를결정
장치에저장 | 실행사이클에서 수행되는 마이크로 -연산들은 명령어의 연산
코드 (OP code) 에따라결정됨 | 연산코드 (OPeration code, OP code)
코드 (OP code) 에따라결정됨 | CPU가수행할연산을지정
코드 (OP code) 에따라결정됨 | 오퍼랜드 (operand)
코드 (OP code) 에따라결정됨 | 명령어실행에필요한데이터가 저장된주소 (addr )
코드 (OP code) 에따라결정됨 | 기억장치에 저장되어 있는데이터를 CPU 내부레지스터인 AC
첫번째주기 (t0) | 첫번째주기 (t0): 명령어레지스터 (IR)에있는명령어의 주소부분을 MAR
두번째주기 (t1) | 두번째주기 (t1): 해당주소가지정한기억장소로부터 데이터를 인출하여
세번째주기 (t2) | 세번째주기 (t2): 해당데이터를 AC에적재
MBR로전송 | [예] CPU 클럭이 2GHz 인경우클럭주기및LOAD 명령어수
행시간 | 클럭의주기 = 1s/(𝟐×𝟏𝟎𝟗) = 0.5 ns
인출및실행사이클 | 인출및실행사이클 : 0.5ns ×(3+3) = 3.0 𝑛𝑠
행시간 | AC 레지스터의 내용을기억장치에 저장하는 명령어 t0: MAR ← IR( addr ) t1: MBR ← AC t2: M[MAR] ← MBR
첫번째주기 (t0) | 첫번째주기 (t0): 데이터를 저장할기억장치의 주소를 MAR로전송
두번째주기 (t1) | 두번째주기 (t1): 저장할데이터를 버퍼레지스터인 MBR로이동
세번째주기 (t2) | 세번째주기 (t2): MBR의내용을 MAR이지정하는 기억장소에 저장
행시간 | 기억장치에 저장된데이터를 AC의내용과더하고 , 그결과는
첫번째주기 (t0) | 첫번째주기 (t0): 명령어레지스터 (IR)에있는명령어의 주소부분을 MAR
두번째주기 (t1) | 두번째주기 (t1): 해당주소가지정한기억장소로부터 데이터를 인출하여
세번째주기 (t2) | 세번째주기 (t2): 해당데이터와 AC의내용을더하고 , 결과값을 다시 AC에
저장 | 오퍼랜드 (addr )가가리키는 위치의명령어로 실행순서를변경
하는분기 (branch) 명령어 (제어명령어 ) | 명령어의 오퍼랜드 (분기할목적지주소 )를PC에저장
하는분기 (branch) 명령어 (제어명령어 ) | 다음명령어인출사이클에서 해당주소의명령어가 인출되므로 , 분기가
발생 | [예] CPU 클럭이 4GHz 인경우클럭주기및JUMP 명령어수행
시간 | 클럭주기 = 1s/(4×𝟏𝟎𝟗) = 0.25 ns
인출및실행사이클 | 인출및실행사이클 : 0.25ns×(3+1) = 1.0 𝑛𝑠
시간 | 연산코드에임의의정수 (10진수 ) 배정
LOAD | LOAD: 1
STA | STA: 2
ADD | ADD: 5
JUMP | JUMP: 8
시간 | [예] 어셈블리 프로그램
시간 | LOAD(1) 250, PC →100번지
시간 | 100번지의첫번째명령어코드가인출되어 IR에저장
시간 | 250번지의데이터를 AC로이동
시간 | PC = PC + 1 = 101
시간 | ADD(5) 251, PC →101번지
시간 | 두번째명령어가 101번지로부터 인출되어 IR에저장
시간 | AC의내용과 251번지의내용을더하고 , 결과를 AC에저장
시간 | PC의내용은 102로증가
시간 | STA(2) 251, PC →102번지
시간 | 세번째명령어가 102번지로부터 인출되어 IR에저장
시간 | AC의내용을 251번지에저장
시간 | PC의내용은 103으로증가
시간 | JUMP(8) 170, PC →103번지
시간 | 네번째명령어가 103번지로부터 인출되어 IR에저장
시간 | 분기될목적지주소 , 즉IR의하위부분 (170)이PC로적재
시간 | 다음명령어인출사이클에서는 170 번지의명령어인출
시간 | 명령어에 포함되어 있는주소를이용하여 , 그명령어실행에필
요한데이터의 주소를인출하는사이클 | 인출사이클과 실행사이클사이에위치
요한데이터의 주소를인출하는사이클 | 간접주소지정 방식 (indirect addressing mode) 에서사용
요한데이터의 주소를인출하는사이클 | 인출된명령어의 주소필드내용을이용하여 기억장치로부터
데이터의 실제주소를인출하여 IR의주소필드에저장 | 간접사이클에서 수행될마이크로 -연산 t0: MAR ← IR( addr ) t1: MBR ← M[MAR] t2: IR( addr )← MBR
첫번째주기 (t0) | 첫번째주기 (t0): 명령어레지스터인 IR에있는명령어의 오퍼랜드 (addr) 값
두번째주기 (t1) | 두번째주기 (t1): 그주소값이지정하는 기억장치 주소로부터 읽혀진데이
세번째주기 (t2) | 세번째주기 (t2): 전송된 MBR의데이터는 유효주소 정보이기에 그값을다
시IR의주소필드로전송 | [예] CPU 클럭이 2GHz 인경우 ADD 명령어내에간접사이클
인출 , 간접 , 실행사이클 | 인출 , 간접 , 실행사이클 : 0.5ns ×(3+3+3) = 4.5 𝑛𝑠
이포함된수행시간 | [예제 ] 프로그램이 아래표와같이작성되었을 때, 프로그램 실행시
간? (단, CPU 클럭은 2GHz이고 , 메모리지연시간은 없다고가정 ) | [풀이 ]
간? (단, CPU 클럭은 2GHz이고 , 메모리지연시간은 없다고가정 ) | 클럭주기 = 1 2×109=0.5𝑛𝑠
LOAD | LOAD : 인출 (3) + 간접 (3) + 실행 (3) = 9개클럭주기
ADD | ADD : 인출 (3) + 간접 (3) + 실행 (3) = 9개클럭주기
STORE | STORE : 인출 (3) + 간접 (0) + 실행 (3) = 6개클럭주기
JUMP | JUMP : 인출 (3) + 간접 (0) + 실행 (1) = 4개클럭주기
간? (단, CPU 클럭은 2GHz이고 , 메모리지연시간은 없다고가정 ) | 프로그램 실행에총28개클럭주기가요구되므로 , 프로그램 실행시간은 28×0.5ns = 14ns주소 명령어 간접사이클 (I)기계코드
103 JUMP 170 0 8170 | 인터럽트 (interrupt)
103 JUMP 170 0 8170 | CPU가정상적인 프로그램 실행중에또다른프로그램의 실행요구로현
재실행중인프로그램을 중단시키고 요구된프로그램을 실행 | 긴급한상황대처나외부장치들과 상호작용을위하여필요
재실행중인프로그램을 중단시키고 요구된프로그램을 실행 | CPU가프로그램 실행중에인터럽트 요구가들어오면 , 원래의프로그램
수행을중단하고 , 요구된인터럽트를 위한서비스프로그램을 먼저수행 | 인터럽트 시스템의 기본요소
수행을중단하고 , 요구된인터럽트를 위한서비스프로그램을 먼저수행 | 인터럽트 요청신호 , 인터럽트 처리루틴 , 인터럽트 서비스루틴
수행을중단하고 , 요구된인터럽트를 위한서비스프로그램을 먼저수행 | 인터럽트 서비스루틴 (Interrupt Service Routine, ISR)
수행을중단하고 , 요구된인터럽트를 위한서비스프로그램을 먼저수행 | 인터럽트를 처리하기 위하여수행되는 프로그램 루틴
수행을중단하고 , 요구된인터럽트를 위한서비스프로그램을 먼저수행 | 인터럽트 벡터테이블 (interrupt vector table)
수행을중단하고 , 요구된인터럽트를 위한서비스프로그램을 먼저수행 | 다양한인터럽트 신호를처리하는 ISR의시작주소를포함
수행을중단하고 , 요구된인터럽트를 위한서비스프로그램을 먼저수행 | 인터럽트 처리과정
수행을중단하고 , 요구된인터럽트를 위한서비스프로그램을 먼저수행 | ①인터럽트 요청신호가발생
수행을중단하고 , 요구된인터럽트를 위한서비스프로그램을 먼저수행 | ②CPU는현재수행중인명령어까지만 완료한후, 수행중인프로그램을
일시중지 | ③수행중인프로그램 상태 (PC의내용등)를안전한장소 ([예] stack)에보
관 | 일반적으로 스택은주기억장치의 끝부분을사용
관 | ④인터럽트의 원인을찾아해당인터럽트 서비스루틴을실행
관 | 해당인터럽트 서비스루틴의시작주소를 PC에적재
관 | ⑤인터럽트 서비스루틴이끝나면보관해두었던레지스터 내용과 PC 내
용을복구하여 인터럽트 당한프로그램을 중단된곳부터다시수행 | 인터럽트 사이클의 마이크로 연산 t0: MBR ← PC t1: MAR ← SP, PC ← ISR 의시작주소 t2: M[MAR] ← MBR, SP ← SP -1
용을복구하여 인터럽트 당한프로그램을 중단된곳부터다시수행 | 스택포인터 (Stack Pointer, SP) 는스택의최상위주소 (top of stack, TOS) 를
첫번째주기 (t0) | 첫번째주기 (t0): PC의내용을 MBR로전송
두번째주기 (t1) | 두번째주기 (t1): SP의내용을 MAR로전송하고 , PC의내용은인터럽트 서
비스루틴의시작주소로변경 | 만약주소지정 단위가 1Byte이고저장될주소는 16bits라면 , t2 에서 SP ← SP –2
세번째주기 (t2) | 세번째주기 (t2): MBR에저장되어 있던원래 PC의내용을스택에저장
로변경 | [예]인터럽트 사이클의 마이크로 연산
로변경 | 프로그램의 첫번째명령어인 LOAD 250 명령어가 실행되는 동안에인터
103 JUMP 170 | SP = 999, ISR 시작주소 = 650번지
103 JUMP 170 | ISR의시작단계에서 레지스터들의 내용을스택에저장
103 JUMP 170 | ISR의마지막단계에서 레지스터들의 내용복원
103 JUMP 170 | 다중인터럽트 (multiple interrupt)
103 JUMP 170 | 인터럽트 서비스루틴을수행하는 동안에다른인터럽트 발생
103 JUMP 170 | 다중인터럽트의 처리방법
103 JUMP 170 | [1] CPU가인터럽트 서비스루틴을처리하고 있는도중에는 새로운인터럽
트요구가들어오더라도 인터럽트 사이클을 수행하지 않는방법 | 인터럽트 플래그 (interrupt flag) ← 인터럽트 불가능 (interrupt disabled) 상태
트요구가들어오더라도 인터럽트 사이클을 수행하지 않는방법 | 시스템운영상중요한프로그램이나 도중에중단할수없는데이터입출력동작
등을위한인터럽트를 처리하는데 사용 | [2] 인터럽트의 우선순위 기반
등을위한인터럽트를 처리하는데 사용 | 우선순위가 낮은인터럽트가 처리되고 있는동안에우선순위가 더높은인터럽
럽트를먼저처리 | 장치 X를위한 ISR X를처리하는 도중에우선순위가더높은
대한제어의흐름 | 외부인터럽트 > 내부인터럽트 >
외부인터럽트 | 외부인터럽트 :전원 , I/O장치 , 타이머등
내부인터럽트 | 내부인터럽트 :잘못된명령어나 데이터
를사용할때,CPU내부에서 발생 | [예] 0으로나누기 , 오버플로우 (overflow), 언
소프트웨어 인터럽트 | 소프트웨어 인터럽트 :프로그램이 작업
[예]SuperVisor Call(SVC) | [예]SuperVisor Call(SVC): 사용자모드에서
을요청하는 인터럽트 | 서브루틴 호출 (subroutine call)
을요청하는 인터럽트 | 한블록으로 구성된명령어실행중에또다른블록으로 구성된명령어를
CALL 명령어 | CALL 명령어 : 현재의 PC 내용을스택에저장하고 서브루틴의 시작주소
RET 명령어 | RET 명령어 : CPU가원래실행하던 프로그램으로 복귀 (return)시키는명령
어 | 단순히실행순서만변경할때사용할때는분기 (branch) 명령어
사용 | CALL X 명령어에 대한마이크로 연산 t0: MBR ← PC t1: MAR ← SP, PC ← X t2: M[MAR]← MBR, SP ← SP -1
사용 | 현재의 PC 내용 (서브루틴 수행완료후에복귀할주소 )을SP가지정하는
스택의최상위 (Top Of Stack, TOS) 에저장 | RET 명령어의 마이크로 연산 t0: SP ← SP + 1 t1: MAR ← SP t2: MBR ← M[MAR] t3: PC ← MBR