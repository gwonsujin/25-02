| 주제/단락               | 내용                                                                                       |
| ------------------- | ---------------------------------------------------------------------------------------- |
| 인출 사이클 루틴           | 인출 사이클은 명령어를 제어기억장치의 마이크로명령어들로 구현한 절차로, 메모리에서 다음 명령어를 읽어와 IR에 적재하고 해당 실행 루틴으로 분기한다.      |
| 마이크로명령어 포맷          | 마이크로명령어는 주소, 두 개의 마이크로연산(μ-ops), 조건필드(CD), 분기필드(BR), 주소필드(ADF)로 구성되어 제어와 분기를 기술한다.       |
| 인출 루틴 시작 주소         | 인출 사이클 루틴의 시작 주소는 ORG 0으로 정의된다.                                                          |
| FETCH 단계            | MAR에 PC를 적재하고 다음 마이크로명령어를 실행하여 인출을 준비한다.                                                 |
| READ 단계(인출)         | MBR에 M[MAR]을 읽고 PC를 PC+1로 증가시켜 다음 명령어 주소를 준비한다.                                          |
| BRTIR 단계            | IR에 MBR을 적재하고 해당 실행 사이클 루틴으로 분기한다.                                                       |
| 간접 사이클 루틴           | 간접 주소 지정이 필요한 경우 IR의 주소 필드를 실제 유효 주소로 치환하기 위한 루틴을 수행한다.                                  |
| 간접 루틴 시작 주소         | 간접 사이클 루틴의 시작 주소는 ORG 4로 정의된다.                                                           |
| INDRT 단계            | MAR에 IR의 주소 필드를 적재하여 간접 주소 해석을 시작한다.                                                     |
| READ 단계(간접)         | MBR에 M[MAR]을 읽어 유효 주소 정보를 획득한다.                                                          |
| BRTIR-RET 단계        | IR의 주소 필드를 MBR 값으로 갱신하고 실행 사이클 루틴으로 복귀한다.                                                |
| 실행 사이클 루틴 개요        | 각 연산코드의 실행 루틴 시작 주소는 사상 방식을 통해 결정되며, 명령어별로 필요한 마이크로연산 서브루틴을 작성한다.                        |
| 연산코드 사상 예시          | 연산코드에 대해 사상 함수(예: 1XXXX00)를 이용해 해당 실행 루틴의 시작 주소를 산출한다.                                   |
| NOP 루틴              | NOP는 PC를 PC+1로 증가시키고 인출 사이클(FETCH)로 점프하여 다음 명령어를 준비한다.                                   |
| NOP 비트 패턴           | NOP의 마이크로명령어 비트 패턴 예시는 Addr, μ-OP, CD, BR, ADF 필드로 제시된다.                                 |
| LOAD(I) 루틴 개요       | LOAD(I)는 필요 시 간접 루틴을 호출한 뒤, 유효 주소에서 데이터를 읽어 누산기 AC에 적재하고 FETCH로 복귀한다.                    |
| LOAD(I) 간접 호출       | I=1이면 CALL INDRT를 통해 간접 주소 해석을 먼저 수행한다.                                                  |
| LOAD(I) 주소 설정       | MAR에 IR의 주소 필드를 적재하여 오퍼랜드 위치를 지정한다.                                                      |
| LOAD(I) 읽기          | 메모리에서 M[MAR]을 읽어 MBR에 저장한다.                                                              |
| LOAD(I) 적재 및 복귀     | AC에 MBR 값을 적재하고 FETCH로 분기하여 다음 명령어 인출을 진행한다.                                             |
| LOAD(I) 비트 패턴       | LOAD(I)의 마이크로명령어 비트 패턴 예시가 단계별 주소와 μ-OP, CD, BR, ADF로 제시된다.                              |
| STORE(I) 루틴 개요      | STORE(I)는 필요 시 간접 루틴을 호출하고, AC 내용을 MBR로 전달한 뒤 해당 주소에 기록하고 FETCH로 복귀한다.                   |
| STORE(I) 간접 호출      | I=1이면 CALL INDRT를 통해 간접 주소를 해석한다.                                                        |
| STORE(I) 주소 설정      | MAR에 IR의 주소 필드를 적재한다.                                                                    |
| STORE(I) 데이터 준비     | AC의 값을 MBR로 이동하여 저장할 데이터를 준비한다.                                                          |
| STORE(I) 쓰기 및 복귀    | M[MAR]에 MBR을 기록하고 FETCH로 분기하여 다음 명령어 인출을 진행한다.                                           |
| STORE(I) 비트 패턴      | STORE(I)의 마이크로명령어 비트 패턴 예시가 단계별로 제시된다.                                                   |
| ADD 루틴 개요           | ADD는 오퍼랜드를 읽어 AC에 더한 뒤 FETCH로 분기하는 서브루틴으로 구현된다.                                          |
| ADD 주소 설정           | MAR에 IR의 주소 필드를 적재한다.                                                                    |
| ADD 읽기              | 메모리에서 M[MAR]을 읽어 MBR에 저장한다.                                                              |
| ADD 누산              | AC에 AC+MBR을 수행하고 FETCH로 분기한다.                                                            |
| ADD 비트 패턴           | ADD의 마이크로명령어 비트 패턴 예시가 단계별로 제시된다.                                                        |
| 제어유니트의 역할           | 제어유니트는 제어기억장치의 마이크로명령어를 순서대로 인출하고, 연산필드 비트를 제어신호로 출력하여 하드웨어를 구동한다.                       |
| 순서제어 개념             | 순서제어는 다음에 실행할 마이크로명령어의 주소를 결정하는 기능으로, CAR가 핵심 레지스터로 사용되며 초기값은 0이다.                       |
| CAR 초기값 의미          | CAR=0은 인출 사이클 루틴의 첫 번째 마이크로명령어 주소를 가리켜 시스템 부팅 시 기본 제어 흐름을 시작한다.                          |
| 멀티플렉서 정의            | 멀티플렉서는 선택선 값에 따라 여러 입력 중 하나를 출력으로 전달하는 조합회로이다.                                           |
| MUX1의 주소 선택         | MUX1은 주소 선택 신호에 따라 CAR+1, ADF, RET, MAP 중 하나를 선택해 다음 마이크로명령어 주소를 결정하고 CAR에 적재한다.         |
| MUX2의 조건 선택         | MUX2는 분기 판단에 사용할 조건 플래그를 선택하여 주소 선택 회로에 전달한다.                                            |
| 주소선택: JUMP/CALL(개요) | BR이 00(JUMP) 또는 01(CALL)일 때 분기 동작은 조건 C의 값에 의해 결정된다.                                     |
| C=0 동작              | C=0이면 다음 위치의 마이크로명령어를 선택한다.                                                              |
| C=1 동작              | C=1이면 주소필드(ADF)가 지정하는 위치로 점프 또는 호출하며, 호출 시에는 CAR 내용을 SBR에 저장한다.                          |
| 주소선택: RET           | BR이 10(RET)이면 SBR의 내용을 CAR로 적재하여 복귀한다.                                                   |
| 주소선택: MAP           | BR이 11(MAP)이면 사상 결과를 CAR에 적재하여 연산코드에 대응하는 루틴으로 분기한다.                                     |
| 제어신호 생성 원리          | 제어기억장치에서 인출된 마이크로명령어의 연산필드 비트들이 외부로 직접 출력되어 개별 제어신호로 사용된다.                               |
| 마이크로프로그래밍 방식        | 제어신호 생성 방식은 수직적과 수평적으로 구분되며, 설계 목표에 따라 메모리 용량, 지연, 병렬성의 상쇄를 고려한다.                        |
| 수직적 마이크로프로그래밍 정의    | 연산필드에 소수의 코드화된 비트를 넣고 해독기(decoder)로 N개의 제어신호를 생성하는 방식이다. 필요 제어신호가 N개면 약 log2N 비트가 필요하다.  |
| 수직적 방식 장점           | 마이크로명령어 길이를 줄여 제어기억장치 용량을 감소시킬 수 있다.                                                     |
| 수직적 방식 단점           | 해독기 등 추가 하드웨어가 필요하고 해독 지연이 발생하며 병렬성이 낮다.                                                 |
| 수평적 마이크로프로그래밍 정의    | 연산필드의 각 비트를 제어신호와 1:1로 대응시켜 비트를 스위치처럼 켜고 끄는 방식으로 제어신호를 직접 발생시킨다.                         |
| 수평적 방식 신호 수         | 필요한 제어신호 수는 연산필드 비트 수와 동일하다.                                                             |
| 수평적 방식 장점           | 해독 지연이 없고 하드웨어가 단순하며 높은 수준의 병렬 처리가 가능하다.                                                 |
| 수평적 방식 단점           | 마이크로명령어 비트 수가 길어져 제어기억장치 용량이 증가한다.                                                       |
