주제/단락 | 내용
---|---
학습목표 | 학습목표
산술및논리연산장치인 ALU의내부구성이 | 산술및논리연산장치인 ALU의내부구성이해
논리연산의원리이해 | 논리연산의원리이해
정수및부동소수점 수의표현방법과산술연산 | 정수및부동소수점 수의표현방법과산술연산이해
학습내용 | 학습내용
ALU의구성요소 | ALU의구성요소
정수의표현 | 정수의표현
논리연산 | 논리연산
시프트연산 | 시프트연산
정수의산술연산 | 정수의산술연산
부동소수점 수의표현 | 부동소수점 수의표현
부동소수점 산술연산 | 부동소수점 산술연산
산술논리연산장치 (Arithmetic | 산술논리연산장치 (Arithmetic and Logical Unit, ALU)
CPU 내부의핵심구성요소로서 , | CPU 내부의핵심구성요소로서 , 산술연산과논리연산을수행하는 하드
웨어모듈 | ALU의구성요소
산술연산장치 | 산술연산장치 : 산술연산들 (+, -, ×, ÷)을수행
논리연산장치 | 논리연산장치 : 논리연산들 (AND, OR, XOR, NOT 등)을수행
시프트레지스터 (shift register) | 시프트레지스터 (shift register): 비트들을 좌측혹은우측으로 이동시키는
보수기 (complementer ) | 보수기 (complementer ): 2진데이터를 2의보수로변환 (음수화 )
상태레지스터 (status register) | 상태레지스터 (status register): 연산결과의상태를나타내는 플래그 (flag)
2진수체계 | 2진수체계 : 0, 1, 부호및소수점으로 수를표현
SZCEVIP | [예] −13.62510=−1101.1012
SZCEVIP | 부호없는정수 (unsigned integer) 표현
SZCEVIP | [예] 10진수부호없는정수를 8-bit 길이의 2진수로표현
255= 11111111 | 𝑛-비트 2진수를부호없는정수𝐴로변환하는 방법
𝑛-비트부호없는정수의표현가능범위 | 𝑛-비트부호없는정수의표현가능범위 : 0~2𝑛−1
1102→1×22+1×21+0×20=610 | 2진수 , 8진수 , 10진수 , 16진수의진법변환
15 1111 17 F | 최상위비트인𝒂𝒏−𝟏의좌측에소수점이 있는소수 (실수에서 정
[예] 232221202-12-22-3 | [예] 232221202-12-22-3 : 자리수 (weight) 1 1 0 1 . 1 0 1
음수표현방법 | 음수표현방법 : 2진수의맨좌측 (최상위 )비트를부호비트 (sign
bit)로활용→부호비트가 0이면양수 , 1이면음수 | 부호화 -크기표현 (signed -magnitude representation)
bit)로활용→부호비트가 0이면양수 , 1이면음수 | 1의보수표현 (1’s complement representation)
bit)로활용→부호비트가 0이면양수 , 1이면음수 | 2의보수표현 (2’s complement representation)
bit)로활용→부호비트가 0이면양수 , 1이면음수 | 부호화 -크기표현
bit)로활용→부호비트가 0이면양수 , 1이면음수 | 맨좌측비트 (Most Significant Bit, MSB )는부호비트 , 나머지 (𝑛− 1)개의비
트들은수의크기 (magnitude) 를나타내는 표현방식 | [예]+ 9 = 0 0001001 + 35 = 0 0100011
트들은수의크기 (magnitude) 를나타내는 표현방식 | 9 = 1 0001001 -35 = 1 0100011
트들은수의크기 (magnitude) 를나타내는 표현방식 | 부호화 -크기로표현된 2진수 (𝑎𝑛−1𝑎𝑛−2⋯𝑎1𝑎0)를10진수로변환
장점 | 장점 : 음수표현방법들중에서가장간단함
단점 | 단점 : 덧셈과뺄셈을수행하기 위해서는 부호비트와크기부분
을별도로처리하는 복잡한과정필요 | ①두수의부호를비교
을별도로처리하는 복잡한과정필요 | ②부호가같은경우에는 크기부분들을 더하고 , 다른경우에는 크기부
분의차이를구함 | ③크기부분의절댓값이 더큰수의부호가부호로세트
분의차이를구함 | 0에대한표현이두개존재
1 0000000 = -0 | 데이터가 ‘0’인지검사하는 과정이복잡함
1 0000000 = -0 | 𝑛-비트단어로표현할수있는수들이2𝑛개가아닌 , (2𝑛−1)개로감소
1 0000000 = -0 | 보수표현 (complement representation): 음수를 2진수로표현하
는방법 | 1의보수 (1’s complement) 표현
는방법 | 모든비트들을 반전 (0 →1, 1 →0)
는방법 | 2의보수 (2’s complement) 표현
는방법 | 모든비트들을 반전하고 , 결과값에 1을더함
는방법 | [예]
+ 9 = 0000 1001 + 35 = 0010 0011 | 9 = 1111 0110 (1 의보수 ) -35 = 1101 1100 (1 의보수 )
+ 9 = 0000 1001 + 35 = 0010 0011 | 9 = 1111 0111 (2 의보수 ) -35 = 1101 1101 (2 의보수 )
+ 9 = 0000 1001 + 35 = 0010 0011 | 8-비트 2진수로표현할수있는 10진수의범위
1의보수 | 1의보수 : −(27−1)~(27−1); −(2𝑛−1−1)~(2𝑛−1−1)
2의보수 | 2의보수 : −(𝟐𝟕)~(𝟐𝟕−𝟏); −(2𝑛−1)~(2𝑛−1−1)
+ 9 = 0000 1001 + 35 = 0010 0011 | 2의보수로표현된양수 (𝑎𝑛−1=0)를10진수로변환하는 방법
+ 9 = 0000 1001 + 35 = 0010 0011 | 𝐴=𝑎𝑛−2×2𝑛−2+𝑎𝑛−3×2𝑛−3+⋯+𝑎1×21+𝑎0×20
+ 9 = 0000 1001 + 35 = 0010 0011 | 2의보수로표현된음수 (𝑎𝑛−1=1)를10진수로변환하는 방법
+ 9 = 0000 1001 + 35 = 0010 0011 | 𝐴=−2𝑛−1+(𝑎𝑛−2×2𝑛−2+𝑎𝑛−3×2𝑛−3+⋯+𝑎1×21+𝑎0×20)
+ 9 = 0000 1001 + 35 = 0010 0011 | [예] 10101110 = -128 + (1 ×25+ 1 ×23+ 1 ×22+ 1 ×21)
= -128 + (32 + 8 + 4 + 2) = -82 | [다른방법 ] 10101110 →01010010 으로먼저변환한후, 음수표시
비트확장 (Bit Extension) | 비트확장 (Bit Extension): 데이터의 길이 (비트수)를늘리는방
법 | 데이터를 더많은비트의레지스터에 저장하거나 , 더긴데이터와 연산을
부호화 -크기표현의비트확장 | 부호화 -크기표현의비트확장 : 부호비트를새로운맨좌측위
치로이동시키고 , 나머지위치들은 0으로채움 | [예제 ]10진수 ‘21’과‘-21’에대한 8-비트길이의부호화 -크기표현을 16-비 트길이로확장하라 .
치로이동시키고 , 나머지위치들은 0으로채움 | [풀이 ]
치로이동시키고 , 나머지위치들은 0으로채움 | +21 = 00010101 (8-비트부호화 -크기표현 )
치로이동시키고 , 나머지위치들은 0으로채움 | +21 = 0000000000010101 (16-비트부호화 -크기표현 )
치로이동시키고 , 나머지위치들은 0으로채움 | 21 = 10010101 (8-비트부호화 -크기표현 )
치로이동시키고 , 나머지위치들은 0으로채움 | 21 = 1000000000010101 (16-비트부호화 -크기표현 )
2의보수표현의비트확장 | 2의보수표현의비트확장 : 확장되는 상위비트들은 부호비트
와같은값으로세트 | 부호 -비트확장 (sign -bit extension) 이라함
와같은값으로세트 | [예제 ]10진수 ‘21’과‘-21’에대한 8-비트길이의 2의보수표현을 16-비트
길이로확장하라 | [풀이 ]
길이로확장하라 | +21 = 00010101 (8-비트 2의보수 )
길이로확장하라 | +21 = 0000000000010101 (16-비트 2의보수 )
길이로확장하라 | 21 = 11101011 (8-비트 2의보수 )
길이로확장하라 | 21 = 1111111111101011 (16-비트 2의보수 )
길이로확장하라 | 기본적인 논리연산들
길이로확장하라 | [예] 논리연산진리표
멀티플렉서 (multiplexer, MUX) | 멀티플렉서 (multiplexer, MUX): 데이터선택기 , 다중화기
길이로확장하라 | 여러개의입력선들중에서하나를선택하여 출력선에연결하는 조합논
리회로 | 선택선들의 값에따라서입력선들중하나가선택
리회로 | 디멀티플렉서 (demultiplexer , DEMUX): 데이터분배기 , 역다중
화기 | 정보를한선으로받아2𝑛개의가능한출력선들중하나를선택하여 , 받은정보
를전송하는 회로 | 하드웨어의 구성
를전송하는 회로 | 입력비트들은 모든논리게이트들을 통과
4×1 멀티플렉서 | 4×1 멀티플렉서 : 4(=22)개의입력들중의하나를선택선 S2과S1에입력된
값에따라서출력으로 보내주는 조합논리회로 | [예]4×1 멀티플렉서를 이용하여 두입력 A, B에대해 AND, OR, XOR, NOT 논리
연산을수행하는 하드웨어 모듈 | N-비트데이터들을 위한논리연산장치
연산을수행하는 하드웨어 모듈 | 기본논리모듈들을 병렬로접속
연산을수행하는 하드웨어 모듈 | [예] 4-비트논리연산장치
연산을수행하는 하드웨어 모듈 | 논리연산들은 레지스터에 저장된데이터단어의전체가아닌
일부비트들에 대해서만 수행될수있음 | 일부비트들의 값을변경하는데 유용하게 사용
기본적인 논리연산 | 기본적인 논리연산 : AND 연산 , OR 연산 , XOR 연산 , NOT 연산
응용된논리연산 | 응용된논리연산 : 선택적 -세트연산 , 선택적 -보수연산 , 마스크
AND 연산 | AND 연산 : 두데이터단어들의 대응되는 비트들간에 AND 연
B=00111011 | 
OR 연산 | OR 연산 : 두데이터단어들의 대응되는 비트들간에 OR 연산
B=00111011 | 
XOR 연산 | XOR 연산 : 두데이터단어들의 대응되는 비트들간에
B=00111011 | 
NOT 연산 | NOT 연산 : 데이터단어의모든비트들을 반전 (invert)
A=10010101(연산전) | 
응용된논리연산 | 응용된논리연산 : 원래데이터를 특정비트들을 적절히세트된
들을변경 | 선택적 -세트 (selective -set) 연산 : 데이터의 일부비트들을 1로세
트해주는 논리적연산 | A 레지스터의 비트들을 중일부를 1로세트하기 위해서 B 레지스터의 비트
들중에서대응되는 위치에있는비트를 1로세트하여 연산을수행 | [예] 레지스터 A에‘10010010’ 이저장되어 있을때, 하위네비트를 1로세 트하라 .
들중에서대응되는 위치에있는비트를 1로세트하여 연산을수행 | OR 연산이용
B=00001111 | 
A=10011111(연산결과 ) | 선택적 -보수 (selective -complement) 연산 : 데이터의 일부비트들
을보수화 (반전 )시키는논리적연산 | B 레지스터의 비트들중에서 1로세트된비트들에 대응되는 A 레지스터의
비트들을 보수로변환 | [예] A 레지스터에 ‘10010101’ 이저장되어 있을때, 하위네비트의값을반 전시켜라 .
비트들을 보수로변환 | XOR 연산이용
B=00001111 | 
마스크 (mask) 연산 | 마스크 (mask) 연산 : 데이터일부비트들을 0으로리셋 (reset)시
키기위한논리적연산 | B 레지스터의 비트들중에서값이 0인비트들과 같은위치에있는 A 레지
스터의비트들을 0으로바꾸는연산 (clear) | [예] A 레지스터에 ‘11110101’ 이저장되어 있을때, 상위세비트를 0으로세 트하라 .
스터의비트들을 0으로바꾸는연산 (clear) | AND 연산이용
B=00011111 | 
삽입 (insert) 연산 | 삽입 (insert) 연산 : 데이터의 일부비트들을 새로운값들로대체
시키기위한논리적연산 | ①삽입할비트위치들에 대하여마스크 (AND) 연산수행
시키기위한논리적연산 | 삽입할위치의비트들을 모두 0으로리셋
시키기위한논리적연산 | ②새롭게삽입할비트들과 OR 연산을수행
시키기위한논리적연산 | [예] A 레지스터에 ‘10010101’ 이저장되어 있을때, 상위네비트를 ‘1110’으 로대체하라 .
B=00001111마스크 (AND연산 ) | 
B=11100000삽입 (OR연산 ) | 
비교 (compare) 연산 | 비교 (compare) 연산 : A와B 레지스터의 내용을비교
A=11100101최종 (삽입 )결과 | XOR 연산활용
A=11100101최종 (삽입 )결과 | 만약대응되는 비트들의 값이같으면→A 레지스터의 해당비트를 ‘0’으로
세트 | 만약서로다르면→A 레지스터의 해당비트를 ‘1’로세트
세트 | 모든비트들이 같으면 (A = 00000000) →Z(zero) 플래그를 1로세트
B = 1 0 0 1 0 1 1 0 | 