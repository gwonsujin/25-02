주제/단락 | 내용
---|---
명령어파이프라이닝 (instructi | 명령어파이프라이닝 (instruction pipelining)
CPU의프로그램 처리속도를높이기위하여 | CPU의프로그램 처리속도를높이기위하여 CPU 내부하드웨어를 여러단
계로나누어동시에처리하는 기술 | 2-단계명령어파이프라인 (two -stage instruction pipeline)
계로나누어동시에처리하는 기술 | 명령어를 실행하는 하드웨어를 인출단계 (fetch stage) 와실행단계 (execute
stage)라는두개의독립적인 파이프라인 모듈로분리 | 두단계들에 동일한클럭으로 동작시간을일치시키면 ,([예]파이프라인의
1단계 = 1 클럭주기 ) | 첫번째클럭주기에서는 인출단계가첫번째명령어를 인출
1단계 = 1 클럭주기 ) | 두번째클럭주기에서는 인출된첫번째명령어가 실행단계로보내져서 실행되
prefetch) | 속도향상 (Speedup, 𝑺𝒑) = 6/4 = 1.5 배
prefetch) | 실행되는 명령어수증가시, 𝑆𝑝는2배에접근
문제 | 문제 : 두단계의처리시간이동일하지 않으면파이프라인 속도
해결방안 | 해결방안 : 파이프라인 단계를세분하여 , 각단계의처리시간
을(거의 ) 같아지도록 함 | 파이프라인 단계의수를늘리면전체적으로 속도향상이더높아짐
명령어인출 (IF) 단계 | 명령어인출 (IF) 단계 : 명령어를 기억장치로부터 인출하는 단계
명령어해독 (ID) 단계 | 명령어해독 (ID) 단계 : 제어유니트에서 해독기 (decoder) 를이용
오퍼랜드 인출 (OF) 단계 | 오퍼랜드 인출 (OF) 단계 : 연산에필요한오퍼랜드 (데이터등)
실행 (EX) 단계 | 실행 (EX) 단계 : 지정된연산을수행하고 , 결과를저장하는 단계
를기억장치로부터 인출하는 단계 | 파이프라인 단계수= 𝑘, 실행할명령어들의 수= 𝑁, 각파이프
파이프라인에 의한전체명령어실행시간 (𝑇𝑘) | 파이프라인에 의한전체명령어실행시간 (𝑇𝑘):
𝑇𝑘=𝑘+(𝑁−1) | 즉, 첫번째명령어를 실행하는데 𝑘주기가걸리고 , 나머지 (𝑁−1) 개의명령어들은
각각한주기씩만 소요 | 만약 , 파이프라인을 사용하지 않을경우 , N개의명령어들을 실행시간 (𝑇1):
파이프라인에 의한속도향상 (𝑆𝑝) | 파이프라인에 의한속도향상 (𝑆𝑝):
𝑘+(𝑁−1) | [예제 ] 파이프라인 단계수= 4, 파이프라인 클럭 = 1GHz(각단
우의속도향상은 ? | [풀이 ] 첫번째명령어실행에걸리는시간 = 4ns, 다음부터는
1ns 마다한개씩의명령어실행완료 | 10개의명령어실행시간 = 4 + (10 -1) = 13ns
1ns 마다한개씩의명령어실행완료 | 속도향상 (𝑆𝑝) = 10×4 13≈3.08배
1ns 마다한개씩의명령어실행완료 | N: CPU 가실행하는 명령어수라면 ,
1ns 마다한개씩의명령어실행완료 | N= 100 일때, 𝑆𝑝=400 103≈3.88
1ns 마다한개씩의명령어실행완료 | N= 1000 일때, 𝑆𝑝=4000 1003≈3.988
1ns 마다한개씩의명령어실행완료 | N= 10000 일때, 𝑆𝑝=40000 10003≈3.9988
1ns 마다한개씩의명령어실행완료 | N= ∞일때, 𝑆𝑝≈4(이론적속도향상 = 단계수)
𝑘+(𝑁−1)=𝐾 | K-단계파이프라이닝 기법을적용하였을 때, 이론적인 성능향
상은실행시간에있어서 , 단계수와동일한 K배임 | 모든명령어들이 파이프라인 단계들을 모두거치지는 않음
상은실행시간에있어서 , 단계수와동일한 K배임 | 어떤명령어는 오퍼랜드 인출이필요없지만 , 파이프라인의 하드웨어를 단
순화시키기 위해서는 모든명령어가 네단계들을 모두통과해야 함 | 파이프라인의 클럭은처리시간이가장오래걸리는단계를기
준으로결정 | [예] IF, ID, OF 의각단계에서 1ns 씩소요되어도 , EX 단계에서 1.5ns 소요되 면, 각단계의처리시간은 1.5ns으로설정됨
해결방안 | 해결방안 : 슈퍼파이프라이닝 (super -pipelining): 명령어파이프라인의 각
여속도를높이도록 설계된기술 | 3개의장애 (hazards)
여속도를높이도록 설계된기술 | 구조적 , 데이터 , 제어등
여속도를높이도록 설계된기술 | 1.구조적장애 (structural hazards)
여속도를높이도록 설계된기술 | 서로다른단계에서 동시에실행되는 명령이컴퓨터내의장치하나를동
시에사용하려고 할때발생 | [예] IF 단계와 OF 단계가동시에기억장치를 액세스하는 경우에 , 기억장치
해결방안 | 해결방안 :메모리가 하나인경우발생→하버드구조사용 or 명령어캐시 (cache),
데이터캐시분리 | 2. 데이터장애 (data hazards)
데이터캐시분리 | 한명령어수행결과가다른명령어의 연산에사용될때, 다른명령어의 파
이프라인의 단계가지연되는 경우발생 | 명령어처리결과사이에데이터의존성 (data dependency) 이존재
이프라인의 단계가지연되는 경우발생 | [예] 파이프라인에서 앞서가는 명령의 ALU 연산결과를레지스터에 저장하기 전
에다른명령에이데이터가 필요한상황 | 해결방안
에다른명령에이데이터가 필요한상황 | ①파이프라인 지연명령 (stall)을사이에끼워넣어프로그램 실행을 1단계
또는 2단계지연 | ②명령어를 재배치하여실행순서를변경
또는 2단계지연 | ③레지스터에 저장되기 전에 , ALU 결과를직접다음명령에직접전달하
연산에서 R1의값을사용함 | 3.제어장애 (control hazards)
연산에서 R1의값을사용함 | 조건분기 (conditional branch) 명령어가 실행되면 , 미리인출하여 처리하던
[예] 명령어 3 | [예] 명령어 3: JUMP 12; jump(if zero) to address 12
명령어들이 무효화됨 | 분기예측 (branch prediction)
명령어들이 무효화됨 | 분기가일어날것인지를예측하고 , 그에따라명령어를 인출하는 확률적
방법 | 분기역사표(branch history table) 이용하여 최근의분기결과를참조
방법 | 분기목적지선인출 (prefetch branch target)
방법 | 조건분기가인식되면 , 분기명령어의 다음명령어뿐만아니라분기의목
적지명령어도 함께인출하여 실행하는 방법 | 조건확인결과에따라 ,유효명령어결과를선택하여 실행
적지명령어도 함께인출하여 실행하는 방법 | 루프버퍼 (loop buffer) 사용
적지명령어도 함께인출하여 실행하는 방법 | 파이프라인의 명령어인출단계에포함되어 있는작은고속기억장치인 루
프버퍼에가장최근인출된 n개의명령어들을 순서대로 저장해두는 방법 | 지연분기 (delayed branch)
프버퍼에가장최근인출된 n개의명령어들을 순서대로 저장해두는 방법 | 분기명령어의 위치를재배치함으로써 파이프라인의 성능을개선하는 방
법 | 슈퍼스칼라 (Superscalar)
법 | CPU의처리속도를더욱높이기위하여 , 내부에두개혹은그이상의명령
어파이프라인들을 포함시킨 구조 | 즉, 하나의프로세서 안에 2개이상의파이프라인 탑재
어파이프라인들을 포함시킨 구조 | 매클럭주기마다 각명령어파이프라인이 별도의명령어를 인
출하여동시에실행 | 이론적으로는 프로그램 처리속도가파이프라인의 수만큼향상가능
파이프라인의 수= m | 파이프라인의 수= m :m-way슈퍼스칼라
단일파이프라인에 의한실행시간 (N | 단일파이프라인에 의한실행시간 (N: 실행할명령어수)
𝑇1=𝑘+𝑁−1 | m-way슈퍼스칼라에 의한실행시간
𝑚 | 속도향상 (𝑆𝑝)
𝑁+𝑚(𝑘−1) | 명령어수𝑵→ ∞, 𝑺𝒑→𝒎
𝑁+𝑚(𝑘−1) | 슈퍼스칼라 프로세서의 속도는파이프라인을 사용하지 않는프로세서에
비해서이론상최대 mk배성능향상가능 | 명령어들 간의데이터의존성
비해서이론상최대 mk배성능향상가능 | 한명령어를 실행한다음에 , 그결과값을 보내주어야 다름명령어의 실행
이가능한관계 | 하드웨어 (레지스터 , 캐시 , 기억장치 등) 이용에대한경합발생
이가능한관계 | 동시실행가능한명령어수< m
해결방안 | 해결방안 :
이가능한관계 | 명령어실행순서재배치→명령어들 간의데이터의존성제거
이가능한관계 | 하드웨어 추가 (중복 ) 설치→하드웨어 (ALU, 레지스터 , 캐시등)에대한경
합감소 | 동적실행 (dynamic execution)
합감소 | 프로그램의 실행시, 명령어들을 컴파일된 순서그대로실행하지 않고 , 데
이터의존성을 고려하여 순서를바꿔실행하는 기법 | 데이터의존성때문에발생하는 유휴사이클 (Idle Cycle) 을줄여 , 슈퍼스칼라 구
조의실행효율을높임 | 동작과정
①명령어인출 (Fetch) | ①명령어인출 (Fetch): 기억장치에서 명령어들을 원래순서대로 인출
②명령어해독 (Decode) | ②명령어해독 (Decode): 해독된정보를명령어풀(Instruction Pool) 에저장
조의실행효율을높임 | ③의존성검사 (Dependency Check): 순서상연속된명령어중데이터의존성때문
④디스패치 (Dispatch) | ④디스패치 (Dispatch): 동시처리가능한명령어들을 실행유닛 (ALU, Load/Store
⑤퇴거 (Retire) | ⑤퇴거 (Retire): 실행이끝난명령어의 결과를프로그램 순서대로 확정 (commit)
하여레지스터 ·메모리에 반영하고 ,명령어풀에서제거 | 실행순서
하여레지스터 ·메모리에 반영하고 ,명령어풀에서제거 | ①매사이클마다 두명령어씩(I1과I2, I3과I4)을순서대로 인출하여 , 해
독하고 , 명령어풀에저장 | ②재배열 /디스패치 유니트가 동시실행가능한명령어들 검색
I1과I2간데이터의존성존재 | I1과I2간데이터의존성존재 : 동시실행불가→원래순서와다르게 , (I1과I3)
(I2와I4)를순차적으로 동시실행 | ③퇴거유니트는 연산처리결과를저장하고 , 실행완료된명령어들 제거
CPU 코어 (core) | CPU 코어 (core): 명령어실행에필요한 CPU 내부의핵심하드
웨어모듈 | 슈퍼스칼라 실행모듈 , 산술논리연산장치 , 부동소수점연산장치 (Floating
Point Unit, FPU), 레지스터 세트 , 제어장치 , 온칩캐시 (on-chip cache) 등 | 멀티 -코어프로세서 (multi -core processor): 여러개의 CPU 코어
들을하나의칩에포함시킨 프로세서 | 칩-레벨다중프로세서 (chip -level multiprocessor) 혹은단일 -칩다중프로세
듀얼 -코어 (dual -core) | 듀얼 -코어 (dual -core): CPU 코어 2개포함
쿼드 -코어 (quad -core) | 쿼드 -코어 (quad -core): CPU 코어 4개포함
헥사 -코어 (hexa -core) | 헥사 -코어 (hexa -core): CPU 코어 6개포함
옥타 -코어 (octa -core) | 옥타 -코어 (octa -core): CPU 코어 8개포함
서(multiprocessor -on-a-chip)이라고도 부름 | 듀얼 -코어프로세서
서(multiprocessor -on-a-chip)이라고도 부름 | 단일코어슈퍼스칼라 프로세서 대비 , 이론적으로 최대 2배성능향상가능
서(multiprocessor -on-a-chip)이라고도 부름 | 코어들은 내부캐시와시스템버스인터페이스만 공유
서(multiprocessor -on-a-chip)이라고도 부름 | 코어별로독립적프로그램 실행하여 멀티 -태스킹 (multi -tasking)과
멀티 -태스킹 | 멀티 -태스킹 : 여러 CPU 코어들을 사용하여 독립적인 프로세스를 동시에
멀티 -스레딩 | 멀티 -스레딩 : 하나의 CPU 코어가여러스레드를 동시에실행
프로세스 (process) | 프로세스 (process): 운영체제가 자원을할당하는 독립적인 작업단위
스레드 (thread) | 스레드 (thread): 독립적으로 실행될수있는최소크기의프로그램 단위
실행 | 여러스레드가 프로세스 자원을공유하면서 독립적으로 실행하여 동시성구현
단일 -스레드모델 (그림 (a)) | 단일 -스레드모델 (그림 (a)): 각코어가스레드를 하나씩처리
실행 | 레지스터 세트 (Register Set, RS)에서스레드의 실행상태를저장하며 , 프로그램
멀티 -스레드모델 (그림 (b)) | 멀티 -스레드모델 (그림 (b)):
카운터 (PC), 스택포인터 (SP), 상태레지스터 등을포함 | 각코어는두개의 RS를보유하여 , 최대두개의스레드를 동시에처리
카운터 (PC), 스택포인터 (SP), 상태레지스터 등을포함 | 두스레드들이 CPU 코어의 H/W 자원들 ([예] ALU, FPU, 온-칩캐시등)을공유
카운터 (PC), 스택포인터 (SP), 상태레지스터 등을포함 | 스레드별 시스템상태 (PC, SP, 상태레지스터 등)는각자의 RS에저장되어 독립
듀얼 -코어멀티 -스레드프로세서 | 듀얼 -코어멀티 -스레드프로세서 : 두개의물리적프로세서 (physical
processor) 들이네개의논리적프로세서 (logical processor) 들로구성 | 혼합형멀티 -코어프로세서 (Hybrid Multi -core Processor)
processor) 들이네개의논리적프로세서 (logical processor) 들로구성 | 성능과전력효율이다른 CPU 코어들을 하나의칩에포함한구조
processor) 들이네개의논리적프로세서 (logical processor) 들로구성 | 복잡한태스크는 고성능 (일반적인 ) 코어가처리
processor) 들이네개의논리적프로세서 (logical processor) 들로구성 | 단순한태스크는 단순구조의저전력코어가처리
processor) 들이네개의논리적프로세서 (logical processor) 들로구성 | 저전력이 중요한랩탑 ·스마트폰 등에서 , 단순태스크 (작업 )과복잡태스크
이혼재된환경을효율적으로 처리 | [예] Intel사의혼합형멀티 -코어프로세서 구조 (최대 20개스레드동시처리 )
P-코어 (performance -core) | P-코어 (performance -core): 고성능 CPU 코어 , 복잡한태스크처리 , 멀티 -스레딩지
E-코어 (efficient -core) | E-코어 (efficient -core): 단순 ·저전력 CPU 코어 , 작은태스크 ·백그라운드 태스크처