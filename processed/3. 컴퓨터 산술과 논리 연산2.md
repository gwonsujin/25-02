주제/단락 | 내용
---|---
논리적시프트 (logical shift) | 논리적시프트 (logical shift): 레지스터 내의데이터비트들을
왼쪽혹은오른쪽으로 한칸씩이동 | 좌측시프트 (Logical Shift Left, LSL)
왼쪽혹은오른쪽으로 한칸씩이동 | 모든비트들을 좌측으로 한칸씩이동
왼쪽혹은오른쪽으로 한칸씩이동 | 최하위비트 (𝐴1)로는 ‘0’이들어오고 , 최상위비트 (𝐴4)는버림
왼쪽혹은오른쪽으로 한칸씩이동 | 우측시프트 (Logical Shift Right, LSR)
왼쪽혹은오른쪽으로 한칸씩이동 | 모든비트들이 우측으로 한칸씩이동
왼쪽혹은오른쪽으로 한칸씩이동 | 최상위비트 (𝐴4)로‘0’이들어오고 , 최하위비트 (𝐴0)는버림
왼쪽혹은오른쪽으로 한칸씩이동 | 시프트기능을가진레지스터의 내부회로
D 플립플롭 (flip-flop) | D 플립플롭 (flip-flop): 1bit의정보를저장하는 논리소자 (logic element)
왼쪽혹은오른쪽으로 한칸씩이동 | 클록펄스가입력되면 기존의저장값이 Q로출력되고 D의입력이 D 플립플롭에
저장됨 | 순환시프트 (circular shift)
저장됨 | 회전 (rotate)이라고도 부르며 , 최상위혹은최하위에 있는비트를버리지않
고반대편끝에있는비트위치로이동 | 순환좌측 -시프트 (circular shift -left): 최상위비트인𝐴4가최하위비트위치
인𝐴1으로이동 | 순환우측 -시프트 (circular shift -right)
A4→ A 3, A3→ A 2, A2→ A 1, A1→A4 | 직렬데이터전송 (serial data transfer)
A4→ A 3, A3→ A 2, A2→ A 1, A1→A4 | 시프트연산을데이터비트수만큼연속적으로 수행함으로써 두레지스터
들사이에한개의선을통하여전체데이터를 이동하는 동작 | 순환시프트연산과논리적시프트연산을활용
들사이에한개의선을통하여전체데이터를 이동하는 동작 | [예제 ]두개의 4-비트레지스터들이 직렬로접속된상태에서 A
값은 ‘0000’으로가정 ) | [풀이 ]
값은 ‘0000’으로가정 ) | 산술적시프트 (arithmetic shift): 수(number)를나타내는 데이터
(부호를가진데이터 )에대한시프트동작 | 시프트과정에서 부호비트는그대로유지시키고 , 수의크기를나타내는
비트들만 시프트 | 산술적좌측 -시프트 (arithmetic shift -left)
A4 (불변 ),A3 ← A2, A2 ← A1, A1 ← 0 | 산술적우측 -시프트 (arithmetic shift -right)
부호비트가그우측의비트로복사 | 부호비트가그우측의비트로복사 :부호 -비트확장
A4 (불변 ),A4 → A3, A3 → A2, A2 → A1 | [예제 ]10진수 -2에대한 4-비트 2진수에대하여산술적좌측 -시
프트를수행한후, 그결과값에대하여두번의산술적우측 -시 | [풀이 ] A = 1 1 1 0 ( -2) : 초기상태 1 1 0 0 ( -4) : 산술적좌측 -시프트결과 1 1 1 0 ( -2) : 첫번째산술적우측 -시프트결과 1 1 1 1 ( -1) : 두번째산술적우측 -시프트결과
프트를수행한후, 그결과값에대하여두번의산술적우측 -시 | 시프트연산은특정산술연산을빠르고효율적으로 수행하기
위해사용됨 | 특히 , 2의거듭제곱수의 곱셈이나 나눗셈을 매우빠르게수행할수있음
양의정수를왼쪽으로 k비트시프트 (LSL) | 양의정수를왼쪽으로 k비트시프트 (LSL):오버플로우가 없다면 , 원래수×2𝑘
양의정수를오른쪽으로 k비트시프트 (LSR) | 양의정수를오른쪽으로 k비트시프트 (LSR):데이터손실이없다면원래수÷2𝑘
위해사용됨 | [예] LSL은2를곱하는효과 (0010 →0100 ), LSR은2로나누는효과 (0010 →
0001 )가발생 | [예]양의정수 n에대해 24 ×n을계산
0001 )가발생 | 24 ×n= (16 + 8) ×n= 24×n+ 23×n이므로 ,
0001 )가발생 | n을4비트왼쪽으로 시프트하면 16 ×n이되고 ,
0001 )가발생 | n을왼쪽으로 3비트시프트하면 8 ×n
0001 )가발생 | 두값의합이 24 ×n
0001 )가발생 | 즉, 시프트두번+ 덧셈한번으로곱셈연산을대체가능
0001 )가발생 | ※ 곱셈연산기보다 시프트 ·덧셈조합이하드웨어적으로 단순하고 빠르므
로, 성능최적화에 널리활용 | 실제 CPU에서는일반적으로 시프트연산에올림수 (C) 플래그
가포함 | SHLC(shift left with carry): C 플래그를 포함한좌측 -시프트
가포함 | SHRC(shift right with carry): C 플래그를 포함한우측 -시프트
가포함 | RLC(rotate left with carry) :C 플래그를 포함하는 좌측순환시프트 (회전 )
연산 | RRC(rotate right with carry) :C 플래그를 포함하는 우측순환시프트 (회전 )
연산 | 산술적우측시프트에서 C 플래그의 값이포함되면 ,
연산 | 데이터의 부호가변경되는 걸방지해야 됨
연산 | 오버플로우 (V) 플래그세트해서 알림
연산 | C 플래그가 레지스터로 들어오지 못하게막음
연산 | 2의보수로표현된수들의덧셈방법
연산 | 두수를더하고 , 만약올림수가 발생하면 버림
연산 | [예]2진수덧셈과 10진수덧셈비교
반가산기 (Half -Adder, HA) | 반가산기 (Half -Adder, HA): 1bit2진수 2개를입력하여 합(Sum,
전가산기 (Full -Adder, FA) | 전가산기 (Full -Adder, FA): 2진수입력 A, B와아랫자리에서 올
로 | 덧셈을수행하는 하드웨어 모듈
로 | 비트수만큼의 전가산기 (FA)들로구성
로 | 덧셈연산결과에따라해당조건플래그들 (condition flags) 을세
V플래그 | V플래그 : 오버플로우 (overflow)
트 | 산술연산의결과데이터가 표현범위를벗어났을 때1로설정
오버플로우 발생 | 오버플로우 발생 : 에러루틴및수정조치
Z플래그 | Z플래그 : 0(zero)
트 | 루프및기타여러용도유용
트 | 1이하나라도 들어있는지를 나타내는 비트를제공하기 위해 OR 회로를사용
트 | Z 비트는 ALU의모든출력비트를 OR한후반전 (NOR)
S플래그 | S플래그 : 부호 (sign)
C플래그 | C플래그 : 올림수 (carry)
트 | 맨왼쪽비트에서 데이터가 넘칠때세트
트 | 가장왼쪽비트의캐리는정상연산에서도 발생하므로 오버플로와 혼동하면 안
덧셈오버플로우 | 덧셈오버플로우 : 덧셈결과가수의표현범위를초과하여 ,결
검출방법 | 검출방법 : 최상위올림수와 차상위올림수간의 XOR를이용
V =C4 XOR C3 | [예]2의보수를이용하여 4bit 덧셈에서 ,오버플로우가 발생하 는지확인하라 .
(a) (+6)+(+3)= (b) (-7)+(-6)= | 오버플로우 발생조건
(a) (+6)+(+3)= (b) (-7)+(-6)= | A의부호비트와 B의부호비트가다르면 , 수의표현범위를벗어나지 않기
때문에오버플로우가 발생하지 않음 | 부호비트가둘다 0인데 , 차상위올림수가 1이면오버플로우가 발생→양
수를더했는데 , 결과값이 음수 | 부호비트가둘다 1인데 , 차상위올림수가 0이면오버플로우가 발생→음
덧셈을이용하여 수행 | 덧셈을이용하여 수행 : 감수에 2의보수를취한후, 피감수와 덧
A-(-B)=A+(+B) | [예]2의보수를이용하여 2진수뺄셈을수행하라 .
뺄셈오버플로우 | 뺄셈오버플로우 : 뺄셈결과가수의표현범위를초과하여 ,결
검출방법 | 검출방법 : 덧셈과동일
V =C4 XOR C3 | [예]2의보수를이용하여 4bit 뺄셈에서 ,오버플로우가 발생하 는지확인하라 .
(a) (+6) -(-4)= (b) (-7)-(+6)= | 4-비트병렬가감산기 (4-bit parallel adder/ subtractor )
(a) (+6) -(-4)= (b) (-7)-(+6)= | 4-비트데이터들 간의덧셈 (A+B) 및뺄셈 (A-B)을모두수행하는 조합회로
(a) (+6) -(-4)= (b) (-7)-(+6)= | 제어신호 M = 0이면 , 덧셈을수행
(a) (+6) -(-4)= (b) (-7)-(+6)= | 제어신호 M = 1이면 , 뺄셈을수행
(a) (+6) -(-4)= (b) (-7)-(+6)= | 입력 B의비트들을 반전하고 , 최하위올림수 (C0)로서 M을입력
(a) (+6) -(-4)= (b) (-7)-(+6)= | 부호없는정수의곱셈
(a) (+6) -(-4)= (b) (-7)-(+6)= | 각비트에대하여부분적(partial product) 계산
(a) (+6) -(-4)= (b) (-7)-(+6)= | 부분적들을모두더하여최종결과를얻음
(a) (+6) -(-4)= (b) (-7)-(+6)= | [예제 ]2진수곱셈 (1101×1011)을수행하고 , 결과값이 10진수곱
셈의결과 (13×11=143)과일치하는가 ? | [풀이 ] 1101 (피승수 = 13)
1000111 (최종결과 = 143) | 부호없는 2진수곱셈기의 하드웨어 구성도
M 레지스터 | M 레지스터 : 피승수 (multiplicand) 저장
Q 레지스터 | Q 레지스터 : 승수 (multiplier) 저장
1000111 (최종결과 = 143) | 두배길이의결과값은 A 레지스터와 Q 레지스터에 저장
1000111 (최종결과 = 143) | Q0 비트가 1이면피승수덧셈후C-A-Q 레지스터 우측시프트 , Q0 비트가 0
이면바로 C-A-Q 레지스터 우측시프트 | Booth 알고리즘 (Booth's algorithm) 사용
이면바로 C-A-Q 레지스터 우측시프트 | M 레지스터와 병렬가산기사이에보수기 (complementer )추가
이면바로 C-A-Q 레지스터 우측시프트 | Q 레지스터의 우측에 1-비트레지스터 (𝑸−𝟏)를추가하고 , 출력을𝑄0와함께
제어회로로입력 | 𝑄0𝑄−1비트가 00 또는 11이면 , A, Q, 𝑄−1산술적우측시프트
제어회로로입력 | 𝑄0𝑄−1비트가 01이면 , A=A+M, 연산후A, Q, 𝑄−1산술적우측시프트
제어회로로입력 | 𝑄0𝑄−1비트가 10이면 , A=A -M, 연산후A, Q, 𝑄−1산술적우측시프트
제어회로로입력 | [예] -7×3=?
10 A=A -MA Q𝑄−1계수 | 0으로둘러싸인 1의블록을가진이진수와 피승수 M의곱
10 A=A -MA Q𝑄−1계수 | [예]M×0011111 0= M ×(25+24+23+22+21)= M ×62
10 A=A -MA Q𝑄−1계수 | 괄호안5번의연산을 2번으로감소할수있음
10 A=A -MA Q𝑄−1계수 | M×(01000000 −00000010) = M ×(26−21)= M ×62
10 A=A -MA Q𝑄−1계수 | 이를일반화시키면 ,(…01…10…) = (…10…00…) –(…00…10…) 로나타낼
수있음 | 한개의 1로구성된블록 (010)도가능
수있음 | [예] M×00111010 = M ×(25+24+23+21)= M ×58
00111000 = 0 1000000 | 00111000 = 0 1000000 –0000 1000 = +26−23
00000 010= 00000 100 | 00000 010= 00000 100 –000000 10= +22−21
수있음 | M ×(26−23+22−21) = M ×58
수있음 | Booth 알고리즘에서 1의블록을처음만났을때(01)덧셈을수
행하고 , 1의블록이끝날때(10) 뺄셈을수행 | 1의블록이길어질수록 연산횟수는감소
행하고 , 1의블록이끝날때(10) 뺄셈을수행 | 나눗셈의 수식표현
행하고 , 1의블록이끝날때(10) 뺄셈을수행 | A ÷B = q · · · · · r
행하고 , 1의블록이끝날때(10) 뺄셈을수행 | A: 피제수 (dividend), B: 제수 (divisor)
행하고 , 1의블록이끝날때(10) 뺄셈을수행 | q: 몫(quotient) r: 나머지수(remainder)
행하고 , 1의블록이끝날때(10) 뺄셈을수행 | 부호없는 2진나눗셈
00010010 | 1011
00010010 | 
0000011101100000 | 
0110000 1좌측시프트 | 
00001110 | 1011
00001110 | 
0000001111000010 | 
110000 11좌측시프트 | 
00001111 | 1011
00001111 | 
00000100000001100 | 
00000110 1좌측시프트 | 
제수뺄셈 , 𝑄0←1 | [예]7÷(-3)
제수뺄셈 , 𝑄0←1 | 제수 (-3)에대한 2의보수표현인 ‘1101’을M 레지스터에 저장하고 , 아래의
연산을순차적으로 수행 | 부호없는 2진수의곱셈
연산을순차적으로 수행 | Q0 비트가 1이면 A A+M (피승수 ), 연산후우측시프트
연산을순차적으로 수행 | Q0 비트가 0이면 , 연산없이우측시프트
연산을순차적으로 수행 | 부호있는 2진수의곱셈 (Booth 알고리즘 )
연산을순차적으로 수행 | Q0Q-1가00 또는 11이면 ,연산없이산술적우측시프트
연산을순차적으로 수행 | Q0Q-1가01이면 , A A+M , 연산후산술적우측시프트
연산을순차적으로 수행 | Q0Q-1가10이면 , A A-M, 연산후산술적우측시프트
연산을순차적으로 수행 | 2N비트의연산결과는 A레지스터와 Q레지스터에 저장
연산을순차적으로 수행 | 부호없는 2진수의나눗셈
연산을순차적으로 수행 | 좌측시프트수행
연산을순차적으로 수행 | 현재 A 레지스터의 값이 M(제수 )보다크면 , A A –M 연산후Q01
연산을순차적으로 수행 | 부호있는 2진수의나눗셈
연산을순차적으로 수행 | 좌측시프트수행
연산을순차적으로 수행 | A, M의부호가같으면 , A A -M수행
연산을순차적으로 수행 | A, M의부호가다르면 , A A+M수행
연산을순차적으로 수행 | 만약연산전후 A 레지스터의 데이터부호가다르고 0이아니면 , A 레지스
터는연산전데이터로 복구 | 그렇지않다면 , Q01
터는연산전데이터로 복구 | A레지스터에는 나머지 ,Q레지스터에 몫이저장
터는연산전데이터로 복구 | 부호가있는 2진수의나눗셈인 경우 , 피제수와 제수의부호가다르면 , Q 레