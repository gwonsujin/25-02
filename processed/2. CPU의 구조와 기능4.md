주제/단락 | 내용
---|---
명령어세트 (instruction s | 명령어세트 (instruction set)
어떤 CPU를위하여정의된명령어들의 집 | 어떤 CPU를위하여정의된명령어들의 집합
명령어세트설계를위해결정되어야 할사항들 | 명령어세트설계를위해결정되어야 할사항들
연산종류 (operation repe | 연산종류 (operation repertoire): CPU가수행할연산들의 수와종류및복
데이터형태 (data type) | 데이터형태 (data type): 연산을수행할데이터들의 형태 , 데이터의 길이 (비
트수), 수의표현방식등 | 명령어형식 (instruction format): 명령어의 길이 , 오퍼랜드 필드들의 수와
길이등 | 주소지정 방식 (addressing mode): 오퍼랜드의 주소를지정하는 방식
데이터전송 | 데이터전송 : 레지스터와 레지스터 간, 레지스터와 기억장치 간,
혹은기억장치와 기억장치 간에데이터를 이동하는 동작 | MOVE, LOAD, STORE 등
산술연산 | 산술연산 : 덧셈 , 뺄셈 , 곱셈및나눗셈과 같은기본적인 산술연
논리연산 | 논리연산 : 데이터의 각비트들간에대한 AND, OR, NOT, XOR
입출력 (I/O) | 입출력 (I/O): CPU와외부장치들간의데이터이동을위한동작
프로그램 제어 | 프로그램 제어 : 명령어실행순서를변경하는 연산들
들 | 분기 (branch), 서브루틴 호출 (subroutine call)
연산코드 (Operation Code) | 연산코드 (Operation Code): 수행될연산을지정
들 | [예] LOAD, ADD 등
들 | 오퍼랜드 (Operand)
들 | 연산을수행하는 데필요한데이터혹은데이터의 주소
들 | 각연산은한개혹은두개의입력오퍼랜드들과 한개의결과오퍼랜드를 포함
들 | 데이터는 CPU 레지스터 , 주기억장치 , 혹은 I/O 장치에위치
들 | 다음명령어주소 (Next Instruction Address)
들 | 현재의명령어실행이완료된후에다음명령어를 인출할위치지정
들 | 분기혹은호출명령어와 같이실행순서를변경하는 경우에필요
들 | 명령어형식 (instruction format): 명령어내필드들의 수와배치
필드 (field) | 필드 (field): 명령어의 각구성요소들에 소요되는 비트들의 그
룹 | 일반적으로 명령어의 길이 = 단어 (word) 길이
룹 | [예] 세개의필드들로 구성된 16-비트명령어
연산코드필드의길이 | 연산코드필드의길이 : 연산의개수를결정
룹 | [예] 4 비트→24= 16 가지의연산정의가능
룹 | 만약연산코드필드가 5 비트로늘어나면 , 25= 32가지연산들정의가능→하지
오퍼랜드 필드의길이 | 오퍼랜드 필드의길이 : 오퍼랜드의 범위결정
만, 다른필드의길이가감소 | 오퍼랜드의 종류에따라범위가달라짐
데이터 | 데이터 : 표현가능한수의범위결정
기억장치 주소 | 기억장치 주소 : CPU가오퍼랜드 인출을위하여직접주소를지정할수있는기억
레지스터 번호 | 레지스터 번호 : 데이터저장에사용될수있는범용레지스터의 개수결정
장치용량결정 | [예] 오퍼랜드 1은레지스터 번호를지정하고 , 오퍼랜드 2는기억
오퍼랜드 1 | 오퍼랜드 1: 4 비트→16 개의레지스터 사용가능
오퍼랜드 2 | 오퍼랜드 2: 8 비트→기억장치의 주소범위는 0 ∼255 번지
장치주소를지정하는 경우 | 두개의오퍼랜드들을 하나로통합하여 사용하는 경우
장치주소를지정하는 경우 | 오퍼랜드가 2의보수로표현되는 데이터라면 ,
표현범위 | 표현범위 : -2048 ∼+2047
장치주소를지정하는 경우 | 오퍼랜드가 기억장치 주소라면 ,
장치주소를지정하는 경우 | 𝟐𝟏𝟐= 4096 개의기억장치 주소들직접지정가능
장치주소를지정하는 경우 | 0-주소명령어 (zero -address instruction)
장치주소를지정하는 경우 | 연산에필요한오퍼랜드 및결과의저장장소가묵시적으로 지정된경우
장치주소를지정하는 경우 | [예] 스택 (stack)을갖는구조 (PUSH, POP)
장치주소를지정하는 경우 | 수식계산시후위표기법 (postfix) 활용
장치주소를지정하는 경우 | 피연자를 먼저표시하고 연산자를 나중에표시하는 방법
중위표기법 | 중위표기법 :(A+B)×(C-D) →후위표기법 : AB+CD -×
장치주소를지정하는 경우 | 1-주소명령어 (one-address instruction): 오퍼랜드를 한개만포
함하는명령어 | 다른한오퍼랜드는 묵시적으로 AC가됨
함하는명령어 | 연산결과는 AC에저장
함하는명령어 | [예] ADD X ; AC ← AC+M[X]
함하는명령어 | 2-주소명령어 (two -address instruction): 두개의오퍼랜드를 포
함하는명령어 | [예] ADD R1, R2 ; R1 ← R1+R2
함하는명령어 | [예] MOV R1, R2 ; R1 ← R2
함하는명령어 | [예] ADD R1, X ; R1 ← R1+M[X]
함하는명령어 | 3-주소명령어 (three -address instruction): 세개의오퍼랜드들
을포함하는 명령어 | 연산후에도입력데이터보존
을포함하는 명령어 | [예] ADD R1, R2, R3 ; R1 ← R2+R3
을포함하는 명령어 | [예제 ] 길이가 16 비트인 1-주소명령어에서 연산코드가 5 비트
인경우의명령어형식을정의하고 , 주소지정 가능한기억장치 | 단, 주소가지정되는 각기억장소에는 한바이트씩 저장된다고 가정한다 .
인경우의명령어형식을정의하고 , 주소지정 가능한기억장치 | [풀이 ]
인경우의명령어형식을정의하고 , 주소지정 가능한기억장치 | 명령어형식 (instruction format)
주소지정 가능한기억장치 용량 | 주소지정 가능한기억장치 용량 : 211×1Bytes = 2048Bytes
인경우의명령어형식을정의하고 , 주소지정 가능한기억장치 | [예제 ]2-주소명령어형식을사용하는 16-비트 CPU에서연산 코드가 5 비트이고 , 레지스터의 수는 8 개이다 .
인경우의명령어형식을정의하고 , 주소지정 가능한기억장치 | (a) 두오퍼랜드들이 모두레지스터 번호인경우의명령어형식은 ?
인경우의명령어형식을정의하고 , 주소지정 가능한기억장치 | (b) 오퍼랜드 하나는레지스터 번호이고 , 나머지는 기억장치 주소인경우
의명령어형식은 ? | [풀이 ]
의명령어형식은 ? | [예제 ] 다음의명령어를 3-주소명령어형식을나타내라 . ADD R1, R2, R3 ; R1 ← R2+R3
의명령어형식은 ? | 여기서명령어의 길이는 16 비트이며 , 필요한연산의종류는 12개이며 ,레 지스터의 숫자는 10개이다 .
의명령어형식은 ? | [풀이 ]
의명령어형식은 ? | [예] X=(A+B) ×(C-D) 계산을위한어셈블리 프로그램 작성
의명령어형식은 ? | 아래와같은니모닉 (Mnemonic) 을가진명령어들을 사용
ADD | ADD : 덧셈
SUB | SUB : 뺄셈
MUL | MUL : 곱셈
DIV | DIV : 나눗셈
MOV | MOV : 데이터이동 (레지스터와 기억장치 간)
LOAD | LOAD : 기억장치로부터 데이터읽어서 AC에적재
STOR | STOR : AC의내용을기억장치로 데이터저장
의명령어형식은 ? | [예] X=(A+B) ×(C-D) 계산을위한어셈블리 프로그램 작성
의명령어형식은 ? | 1-주소명령어를사용한프로그램 (단, M[i]는기억장치 i번지의내용 , T는
기억장치 내임시저장장소의주소 ) | LOAD A ; AC ← M[A]
기억장치 내임시저장장소의주소 ) | ADD B ; AC ← AC + M[B]
기억장치 내임시저장장소의주소 ) | STOR T ; M[T] ← AC
기억장치 내임시저장장소의주소 ) | LOAD C ; AC ← M[C]
기억장치 내임시저장장소의주소 ) | SUB D ; AC ← AC -M[D]
기억장치 내임시저장장소의주소 ) | MUL T ; AC ← AC ×M[T]
기억장치 내임시저장장소의주소 ) | STOR X ; M[X] ← AC
기억장치 내임시저장장소의주소 ) | 프로그램의 길이 = 7
기억장치 내임시저장장소의주소 ) | [예] X=(A+B) ×(C-D) 계산을위한어셈블리 프로그램 작성
기억장치 내임시저장장소의주소 ) | 2-주소명령어를사용한프로그램 (레지스터 R1, R2 활용 )
기억장치 내임시저장장소의주소 ) | MOV R1, A ; R1 ← M[A]
기억장치 내임시저장장소의주소 ) | ADD R1, B ; R1 ← R1 + M[B]
기억장치 내임시저장장소의주소 ) | MOV R2, C ; R2 ← M[C]
기억장치 내임시저장장소의주소 ) | SUB R2, D ; R2 ← R2 -M[D]
기억장치 내임시저장장소의주소 ) | MUL R1, R2 ; R1 ← R1 ×R2
기억장치 내임시저장장소의주소 ) | MOV X, R1 ; M[X] ← R1
기억장치 내임시저장장소의주소 ) | 프로그램의 길이 = 6
기억장치 내임시저장장소의주소 ) | [예] X=(A+B) ×(C-D) 계산을위한어셈블리 프로그램 작성
기억장치 내임시저장장소의주소 ) | 3-주소명령어를사용한프로그램 (레지스터 R1, R2 활용 )
기억장치 내임시저장장소의주소 ) | ADD R1, A, B ; R1 ← M[A] + M[B]
기억장치 내임시저장장소의주소 ) | SUB R2, C, D ; R2 ← M[C] -M[D]
기억장치 내임시저장장소의주소 ) | MUL X, R1, R2 ; M[X] ← R1 ×R2
기억장치 내임시저장장소의주소 ) | 프로그램의 길이 = 3
장점 | 장점 :프로그램의 길이가짧아지며 , 입력데이터 (A, B, C, D) 가보존됨
단점 | 단점 : 명령어해독과정이복잡함
기억장치 내임시저장장소의주소 ) | 주소지정 방식 (addressing mode)
기억장치 내임시저장장소의주소 ) | 명령어실행에필요한오퍼랜드의 유효주소를결정하는 방식
기억장치 내임시저장장소의주소 ) | 주소지정방식의 종류와수는다양하고 , CPU마다다름
다양한주소지정 방식을사용하는 이유 | 다양한주소지정 방식을사용하는 이유 :
기억장치 내임시저장장소의주소 ) | 일반적으로 명령어비트의수는 CPU가처리하는 단어의길이와같도록제
한 | 제한된수의명령어비트들을 이용하여 , 사용자 (프로그래머 )가다양한방
사용하기위해 | 명령어내오퍼랜드 필드의내용
기억장치 주소 | 기억장치 주소 : 데이터가 저장된기억장치의 위치를지정
레지스터 번호 | 레지스터 번호 : 데이터가 저장된레지스터를 지정
데이터 | 데이터 : 명령어의 오퍼랜드 필드에데이터가 포함
사용하기위해 | 기호
EA | EA: 데이터가 저장된기억장치의 실제주소 (유효주소 , Effective Address)
사용하기위해 | A: 명령어내의주소필드내용 (오퍼랜드 필드의내용이기억장치 주소인
경우 ) | R: 명령어내의레지스터 번호 (오퍼랜드 필드의내용이레지스터 번호인
(A) | (A): 기억장치 A 번지의내용
(R) | (R): 레지스터 R의내용
경우 ) | 주소지정 방식의종류
경우 ) | 직접주소지정 방식
경우 ) | 간접주소지정 방식
경우 ) | 묵시적주소지정 방식
경우 ) | 즉시주소지정 방식
경우 ) | 레지스터 주소지정 방식
경우 ) | 레지스터 간접주소지정 방식
경우 ) | 변위주소지정 방식
경우 ) | 상대주소지정 방식
경우 ) | 인덱스주소지정 방식
경우 ) | 베이스 -레지스터 주소지정 방식
경우 ) | 직접주소지정 방식 (direct addressing mode)
경우 ) | 오퍼랜드 필드의내용이유효주소 (EA)가되는방식
장점 | 장점 : 데이터인출을위하여한번의기억장치 액세스만 필요
단점 | 단점 : 연산코드를제외하고 남은비트들만 주소비트로사용될수있기때
문에직접지정할수있는기억장치의주소가제한 | [예제 ] CPU 레지스터 길이와주소지정 단위는 16비트로가정
문에직접지정할수있는기억장치의주소가제한 | [1] 직접주소지정 방식을사용하는 명령어의 주소필드 (A)에저장된내용이
150일때 , 유효주소 (EA) 및그에인출되는 데이터는 ? | [2] 명령어길이가 16비트이고 연산코드가 5비트라면 , 이명령어에 의해직
접주소지정될수있는기억장치 용량 (Bytes)은얼마인가 ? | [풀이 ]
접주소지정될수있는기억장치 용량 (Bytes)은얼마인가 ? | [1] EA= 150이므로 , 기억장치에 저장 된데이터 ‘1234’가인출된다 .
접주소지정될수있는기억장치 용량 (Bytes)은얼마인가 ? | [2] 주소필드가 11비트이므로 , 총
므로 , 기억장치 용량은 4096Bytes 이 | 간접주소지정 방식 (indirect addressing mode)
므로 , 기억장치 용량은 4096Bytes 이 | 오퍼랜드 필드에기억장치 주소가저장되어 있지만 , 그주소가가리키는
장점 | 장점 : 최대기억장치용량이 단어의길이에의하여결정
EA = (A) | 주소지정이 가능한기억장치 용량확장
EA = (A) | 단어길이가𝑛비트라면 , 최대2𝑛개의기억장소에대한주소지정이 가능
단점 | 단점 : 간접및실행사이클동안에두번의기억장치 액세스가
첫번째액세스 | 첫번째액세스 : 유효주소인출
두번째액세스 | 두번째액세스 : 해당주소가지정하는 기억장소로부터 실제데이터인출
필요 | 명령어형식에간접비트 (I) 필요
필요 | 만약 I = 0 이면 , 직접주소지정 방식
필요 | 만약 I = 1 이면 , 간접주소지정 방식→간접사이클실행
필요 | 다단계 (multi -level) 간접주소지정 방식 EA = ((..(A)..))
필요 | [예제 ] CPU 레지스터 길이와주소지정 단위는 16비트로가정
필요 | [3] 간접주소지정 방식을사용하는 명령어의 주소필드 (A)에저장된내용
이‘172’라고가정했을 때, 유효주소 (EA) 및그에의해인출되는 데이터는 ? | [4] 이명령어에 의해주소지정 될수있는기억장치 용량 (Bytes)은얼마인
가? | [풀이 ]
가? | [3] EA는기억장치 172번지에저장되 는있는 ‘202’이다 . 따라서명령어실
202번지에저장되어 있는 ‘3256’이 | [4] 주소 (EA)의길이는 16비트가되
용량은216(64K) ×2Bytes = | 묵시적주소지정 방식 (implied addressing mode)
용량은216(64K) ×2Bytes = | 명령어실행에필요한데이터의 위치가묵시적으로 지정되는 방식
[예] ‘PUSH R1’ 명령어 | [예] ‘PUSH R1’ 명령어 : 레지스터 R1의내용을스택에저장
용량은216(64K) ×2Bytes = | SP가가리키는 기억장소 (TOS)에R1의내용을저장한다는 것이묵시적으로 정해
[예] ‘POP’ 명령어 | [예] ‘POP’ 명령어 : TOS에있는값을누산기로 인출
[예] ‘SHL’ 명령어 | [예] ‘SHL’ 명령어 : 누산기의 내용을좌측으로 시프트 (shift)
장점 | 장점 : 오퍼랜드의 수가 0 또는 1이기때문에명령어길이가짧음
단점 | 단점 : 종류가제한됨
짐 | 즉시주소지정 방식 (immediate addressing mode)
짐 | 데이터가 명령어에 포함되어 있는방식
짐 | 즉, 오퍼랜드 필드의내용이연산에사용할실제데이터
용도 | 용도 : 프로그램에서 레지스터나 변수의초기값을어떤상수값 (constant
장점 | 장점 : 데이터를 인출하기 위하여기억장치를 액세스할 필요가없음
단점 | 단점 : 상수값의 크기가오퍼랜드 필드의비트수에의해제한됨
value)으로세트하는데사용 | 레지스터 주소지정 방식 (register addressing mode)
value)으로세트하는데사용 | 연산에사용될데이터가 CPU 내부레지스터에 저장되어 있는경우에사용
value)으로세트하는데사용 | 명령어의 오퍼랜드가 해당레지스터를 가리키는 방식
EA = R | 주소지정에 사용될수있는레지스터들의 수= 2𝑘개
EA = R | 𝑘는R필드의비트수
장점 | 장점 :
EA = R | 오퍼랜드 필드의비트수가적어도됨
EA = R | 데이터인출을위하여주기억장치 액세스가 필요없음
EA = R | CPU 내부레지스터에 대한액세스시간이주기억장치 액세스시간보다 훨씬짧
단점 | 단점 :
기대문에 , 명령어실행시간이짧아짐 | 데이터가 저장될수있는공간이 CPU 내부레지스터들로 제한
기대문에 , 명령어실행시간이짧아짐 | 레지스터 간접주소지정 방식 (register -indirect address mode)
기대문에 , 명령어실행시간이짧아짐 | 오퍼랜드 필드 (레지스터 번호 )가가리키는 레지스터의 내용을유효주소로
장점 | 장점 : 주소지정 할수있는기억장치 영역이확장
EA = (R) | 레지스터의 길이 = 16 비트라면 , 지정가능한기억장치의 주소 : 216= 64K개
EA = (R) | 레지스터의 길이 = 32 비트라면 , 지정가능한기억장치의 주소 : 232= 4G개
단점 | 단점 : 데이터인출을위하여한번의기억장치 액세스가 필요
EA = (R) | [예제 ] 명령어의 레지스터 필드 R에‘2’가저장됨
EA = (R) | [5] 레지스터 주소지정 방식이사용된다면 , 연산처리과정에서 어떤데이
터가사용될것인가 ? | [6] 레지스터 간접주소지정 방식이사용된다면 , 연산처리과정에서 어떤
데이터가 사용될것인가 ? | [풀이 ]
데이터가 사용될것인가 ? | [5] R2에저장되어 있는데이터 ‘151’
이사용됨 | [6] 기억장치 151번지에저장되어 있
는데이터 ‘5678’이사용됨 | 변위주소지정 방식 (displacement addressing)
는데이터 ‘5678’이사용됨 | 직접주소지정과 레지스터 간접주소지정 방식의조합
는데이터 ‘5678’이사용됨 | 지정된레지스터에 저장된주소에명령어오퍼랜드의 변위 (offset)를더하
EA = A + (R) | 사용되는 레지스터에 따라다양한변위주소지정 방식가능
PC | PC: 상대주소지정 방식 (relative addressing mode)
인덱스레지스터 | 인덱스레지스터 :인덱스주소지정 방식 (indexed addressing mode)
베이스레지스터 | 베이스레지스터 :베이스 -레지스터 주소지정 방식 (base -register addressing mode)
EA = A + (R) | 상대주소지정 방식 (relative addressing mode)
EA = A + (R) | 프로그램 카운터 (PC)를레지스터로 사용하여 EA를계산
EA = A+ (PC) 단, A는2의보수 | 주로분기명령어에서사용
A > 0 | A > 0: 앞(forward) 방향으로 분기
A ＜0 | A ＜0: 뒷(backward) 방향으로 분기
장점 | 장점 : 전체기억장치 주소가명령어에 포함되어야 하는일반적인 분기명
령어보다 적은수의비트만필요 | PC가묵시적으로 지정될수있으므로 레지스터 필드가필요없음
단점 | 단점 : 분기범위가오퍼랜드 필드의길이에의해제한
령어보다 적은수의비트만필요 | 오퍼랜드 비트들로 표현가능한 2의보수범위
령어보다 적은수의비트만필요 | [예제 ] 상대주소지정 방식을사용하는 JUMP 명령어가 450번지
에저장됨 | [1] 만약오퍼랜드 A = ‘21’이라면 , 몇번지로분기하는가 ?
에저장됨 | [2] 만약오퍼랜드 A = ‘ -50’이라면 , 몇번지로분기하는가 ?
에저장됨 | [풀이 ]
에저장됨 | [1] 이명령어가 인출된후에는 PC의내용이 451로증가되므로 , 451 + 21 =
472번지로분기하게 됨 | [2] 위와같은원리로 , 451 -50 = 401번지로분기하게 됨
472번지로분기하게 됨 | 인덱스주소지정 방식 (indexed addressing mode)
472번지로분기하게 됨 | 인덱스레지스터의 내용과변위 A를더하여유효주소를결정
인덱스레지스터 (IX) | 인덱스레지스터 (IX): 인덱스 (index) 값을저장하는 특수 -목적레지스터
주요용도 | 주요용도 : 배열데이터액세스
EA = (IX) + A | 주소 A는기억장치에 저장된데이터배열의시작주소
EA = (IX) + A | 자동인덱싱 (auto -indexing)
EA = (IX) + A | 명령어가 실행될때마다인덱스레지스터의 내용이자동적으로 증가혹은감소
EA = (IX) + A | 이방식을사용하는 명령어가 실행되면 아래의두연산이연속적으로 수행됨
IX IX + 1 | [예] 데이터배열이기억장치의 500번지부터 저장되어 있고 , 명
터의내용 (IX) = 3 이면 , | 데이터배열의네번째데이터액세스
터의내용 (IX) = 3 이면 , | 베이스 -레지스터 주소지정 방식 (base -register addressing mode)
터의내용 (IX) = 3 이면 , | 베이스레지스터의 내용과변위 A를더하여유효주소를결정
베이스레지스터 (BR) | 베이스레지스터 (BR): 기준 (base)이되는프로그램이나 데이터블록의시작주소
주요용도 | 주요용도 : 프로그램의 시작위치지정하거나 변경하는 데사용
EA = (BR) + A | 다중프로그래밍 (multiprogramming) 환경에서 프로그램 코드및데이터를 메모리
치가쉬움 | 주소지정 방식의종류
치가쉬움 | 직접주소지정 방식
치가쉬움 | 간접주소지정 방식
치가쉬움 | 묵시적주소지정 방식
치가쉬움 | 즉시주소지정 방식
치가쉬움 | 레지스터 주소지정 방식
치가쉬움 | 레지스터 간접주소지정 방식
치가쉬움 | 변위주소지정 방식
치가쉬움 | 상대주소지정 방식
치가쉬움 | 인덱스주소지정 방식
치가쉬움 | 베이스 -레지스터 주소지정 방식
치가쉬움 | CISC(Complex Instruction Set Computer): 복잡명령어집합컴
퓨터 | 명령어형식이복잡함
퓨터 | 많은명령어들을 지원→명령어들의 수가많음
퓨터 | 명령어길이가일정하지 않음→명령어종류에따라달라짐
퓨터 | 주소지정 방식이매우다양함→명령어실행시간이김
퓨터 | 프로그램 길이가감소
퓨터 | RISC(Reduced Instruction Set Computer): 축소명령어집합컴
퓨터 | 명령어형식이간단함
퓨터 | 명령어들의 수를최소화
퓨터 | 명령어길이를일정하게 고정
퓨터 | 주소지정 방식의종류를단순화
퓨터 | 프로그램 길이가증가