| 주제/단락           | 내용                                                                                                                                                   |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 자료 출처           | 트리 탐색 강의 자료는 국립금오공과대학교 컴퓨터공학부 김성영 교수의 자료로, 황준하 교수 자료를 참조하여 수정된 것이다.                                 |
| 목차                | 강의는 Introduction, Uninformed Search와 그 하위 기법들(BFS, UCS, DFS, DLS, IDS), Informed Search와 그 하위 기법들(Greedy Best-first, A\*)로 구성된다. |
| 트리 탐색 정의      | 트리 탐색은 초기 상태부터 목표 상태를 찾을 때까지 상태 공간 위에 탐색 트리를 만들어 가는 과정이다.                                                     |
| 상태 공간 정의      | 상태 공간은 초기 상태와 목표 상태를 포함한 모든 가능한 상태들의 집합으로, 탐색이 이루어지는 문제의 전체 공간을 의미한다.                               |
| 루트 노드 의미      | 탐색 트리의 루트 노드는 문제의 초기 상태에 해당하며 탐색의 시작점을 나타낸다.                                                                          |
| 연산자와 확장       | 현재 상태에 연산자를 적용해 자식 상태들을 생성하는 과정을 노드 확장이라고 한다.                                                                        |
| 반복 확장과 해 도출 | 목표 상태가 발견될 때까지 노드 확장을 반복해 하나의 해를 도출한다.                                                                                     |
| 탐색 전략 개념      | 어떤 노드를 먼저 확장할지 결정하는 규칙을 탐색 전략이라 하며, 전략에 따라 탐색 성능과 결과가 달라진다.                                                 |
| 대표 탐색 전략      | 깊이 우선 탐색과 너비 우선 탐색 등 다양한 트리 탐색 알고리즘이 존재한다.                                                                               |
| 최단 경로 문제 정의 | 예시 문제는 출발 도시 A에서 목표 도시 M까지 총 경로 비용이 최소가 되는 경로를 찾는 것이다.                                                             |
| 출발과 목표 상태    | 초기 상태는 도시 A, 목표 상태는 도시 M으로 주어지며 간선 가중치는 도시 간 이동 비용을 나타낸다.                                                        |
| 노드 확장 과정      | 노드 확장은 선택된 상태를 펼쳐 이웃 상태들을 생성하는 절차로, 탐색 순서는 선택 전략에 의해 결정된다.                                                   |
| 중복 상태 제거      | 실제 적용에서는 이미 방문한 상태를 재방문하지 않도록 관리해 무한 반복을 방지한다.                                                                      |
| 확장 선택 다양성    | 어떤 노드를 확장할지에 따라 서로 다른 탐색 경로와 해가 생성되므로 다양한 알고리즘 설계가 가능하다.                                                     |
| 노드 개념           | 노드는 상태, 부모 노드, 연산자, 깊이, 경로 비용 등 탐색에 필요한 정보를 포함한다.                                                                      |
| 상태 필드           | 상태는 현재 노드가 나타내는 문제의 구체적 구성을 의미한다.                                                                                             |
| 부모 노드 필드      | 부모 노드는 현재 노드가 어디서부터 왔는지 추적하여 경로를 복원할 수 있게 한다.                                                                         |
| 연산자 필드         | 연산자는 부모 상태에서 현재 상태로 이동하게 한 동작을 기록한다.                                                                                        |
| 깊이 필드           | 깊이는 루트로부터의 거리로, 루트의 깊이는 0이며 자식으로 갈수록 1씩 증가한다.                                                                          |
| 경로 비용 필드      | 경로 비용은 초기 상태부터 현재 노드까지 누적된 비용의 합이다.                                                                                          |
| 프린지 정의         | 프린지(프론티어)는 아직 확장되지 않은 노드들을 임시 저장하는 구조이며, 선택된 노드는 이곳에서 제거되어 확장된다.                                       |
| DFS의 프린지        | 깊이 우선 탐색은 프린지를 스택으로 구현해 최근에 추가된 노드부터 확장한다.                                                                             |
| BFS의 프린지        | 너비 우선 탐색은 프린지를 큐로 구현해 먼저 추가된 노드부터 확장한다.                                                                                   |
| 일반 알고리즘 절차  | 초기 노드를 생성해 프린지에 넣고, 프린지가 빌 때까지 노드를 선택·확장하며 목표 검사를 수행한다.                                                        |
| 해의 도출 여부      | 알고리즘이 시간이 충분할 때 해를 반드시 찾을 수 있는지를 나타내는 성질을 완전성이라 한다.                                                              |
| 최적해 도출 여부    | 알고리즘이 반환하는 해가 비용 기준으로 최적임을 보장하는지를 최적성이라 한다.                                                                          |
| 시간 복잡도 정의    | 최악의 경우 해를 찾기 위해 확장되는 노드의 수를 기준으로 시간 복잡도를 측정한다.                                                                       |
| 공간 복잡도 정의    | 탐색 중 동시에 저장해야 하는 최대 노드 수를 기준으로 공간 복잡도를 측정한다.                                                                           |
| 무정보 탐색 정의    | 무정보 탐색은 초기부터 현재까지의 경로 정보만을 사용해 확장 노드를 선택한다.                                                                           |
| 무정보 기법 목록    | 너비 우선 탐색, 균일 비용 탐색, 깊이 우선 탐색, 깊이 제한 탐색, 반복적 깊이 증가 탐색이 포함된다.                                                      |
| 유정보 탐색 정의    | 유정보 탐색은 현재 상태에서 목표까지의 정보를 휴리스틱으로 활용해 확장 순서를 결정한다.                                                                |
| 휴리스틱 활용       | 목표까지의 추정치를 사용해 어떤 자식 노드를 먼저 확장할지 판단한다.                                                                                    |
| 유정보 기법 목록    | Greedy Best-first 탐색과 A\* 탐색이 대표적이다.                                                                                                        |
| BFS 확장 원칙       | 너비 우선 탐색은 깊이가 얕은 노드부터 차례로 확장한다.                                                                                                 |
| BFS 구현 구조       | BFS는 프린지를 큐로 두어 먼저 들어온 노드부터 꺼내 확장한다.                                                                                           |
| BFS 예시 순서       | 목표가 깊이 3의 9번 노드인 경우 확장 순서는 루트에서 깊이 순으로 증가한다.                                                                             |
| BFS 가정            | 최단 경로 예시에서는 이미 지나간 상태로의 이동을 허용하지 않는 것으로 가정한다.                                                                        |
| BFS 확장 결과       | 예시 그래프에서의 확장 순서는 A, B, D, H, C, E, C, I, L, H, F, B, J, K, M 순서로 진행된다.                                                             |
| BFS 최종 해         | 예시의 최종 해는 A에서 H, L을 거쳐 M에 이르는 경로이며 깊이 기준으로는 최적이다.                                                                       |
| 막다른 길 개념      | 확장할 자식이 더 이상 없는 상태는 막다른 길로, 탐색은 다른 프린지 노드로 전환된다.                                                                     |
| BFS 완전성          | 충분한 시간이 주어지면 BFS는 항상 해를 찾는다.                                                                                                         |
| BFS 최적성          | 깊이 기준으로는 최적 해를 보장하지만 간선 비용이 다를 경우 거리 기준 최적성은 보장하지 않는다.                                                         |
| BFS 시간 복잡도     | 분기계수가 b이고 해의 깊이가 d일 때 시간 복잡도는 O(b^d)이다.                                                                                          |
| BFS 공간 복잡도     | 모든 동일 또는 얕은 깊이 노드를 저장해야 하므로 공간 복잡도도 O(b^d)이다.                                                                              |
| BFS 자원 예시       | 분기계수 10, 노드 평가 1ms, 노드당 100바이트일 때 깊이가 증가함에 따라 시간과 메모리 요구가 급격히 증가한다.                                           |
| UCS 정의            | 균일 비용 탐색은 현재까지의 경로 비용이 가장 작은 노드를 우선 확장한다.                                                                                |
| UCS 최적 보장 조건  | 연산 적용 후의 경로 비용이 항상 증가하는 환경에서 UCS는 경로 비용 기준의 최적 해를 보장한다.                                                           |
| UCS 적용 특징       | 예시 그래프에서 누적 비용이 낮은 경로를 우선 확장하여 목표에 도달한다.                                                                                 |
| UCS 완전성          | 시간이 충분하면 UCS는 해를 찾는다.                                                                                                                     |
| UCS 최적성          | 경로 비용 기준으로 최적 해를 보장하지만 깊이 기준 최적성은 보장하지 않는다.                                                                            |
| UCS 시간 복잡도     | 분기계수 b, 해의 깊이 d에 대해 O(b^d)의 시간 복잡도를 갖는다.                                                                                          |
| UCS 공간 복잡도     | 최악의 경우 많은 노드를 저장해야 하므로 공간 복잡도는 O(b^d)이다.                                                                                      |
| DFS 확장 원칙       | 깊이 우선 탐색은 현재 확장 중인 노드의 자식부터 계속 내려가며 확장한다.                                                                                |
| DFS 구현 구조       | DFS는 프린지를 스택으로 두어 가장 최근에 추가된 노드를 우선 확장한다.                                                                                  |
| DFS 예시 순서       | 목표가 깊이 3의 12번 노드인 경우 확장 순서는 루트에서 자식으로 계속 내려가며 진행된다.                                                                 |
| DFS 적용 순서       | 예시 그래프에서의 확장 순서는 A, B, C, H, I, J, G, F, E, D, K, M 순서로 진행된다.                                                                      |
| DFS 최종 해         | 예시의 도달 경로는 A에서 B, C, H, I, J, K를 거쳐 M에 이르는 경로이다.                                                                                  |
| DFS 완전성          | 사이클이나 무한 분기가 존재하면 해를 보장하지 못하므로 설계 시 주의가 필요하다.                                                                        |
| DFS 최적성          | 깊이와 비용 기준 모두에서 최적 해를 보장하지 않는다.                                                                                                   |
| DFS 시간 복잡도     | 최대 깊이가 m이면 시간 복잡도는 O(b^m)이다.                                                                                                            |
| DFS 공간 복잡도     | 한때 저장할 노드 수가 경로 길이에 비례하므로 공간 복잡도는 O(b^m)이다.                                                                                 |
| 깊이 제한 탐색 개념 | 깊이 제한 탐색은 미리 정한 깊이 제한까지 DFS를 수행해 그 깊이를 넘는 확장을 금지한다.                                                                  |
| 깊이 제한 설정      | 효과적인 탐색을 위해 적절한 깊이 제한 값을 선택하는 것이 중요하다.                                                                                     |
| DLS depth limit 예  | 깊이 제한을 4로 설정하면 해당 깊이까지만 확장하여 목표를 탐색한다.                                                                                     |
| DLS 확장 순서       | 예시에서 상태 확장은 제한 깊이 내에서 좌우 하위 노드를 차례대로 방문한다.                                                                              |
| DLS 최종 해         | 예시의 최종 해는 A, H, I, K, M 경로로 제한 깊이 내에서 도달 가능하다.                                                                                  |
| DLS 완전성 조건     | 깊이 제한이 실제 해의 깊이 이상으로 설정되어야 해를 찾을 수 있다.                                                                                      |
| DLS 최적성          | 깊이와 비용 기준의 최적성을 보장하지 않는다.                                                                                                           |
| DLS 시간 복잡도     | 깊이 제한을 l이라 할 때 시간 복잡도는 O(b^l)이다.                                                                                                      |
| DLS 공간 복잡도     | DFS 기반이므로 공간 복잡도도 O(b^l)이다.                                                                                                               |
| IDS 개념            | 반복적 깊이 증가 탐색은 깊이 제한 탐색을 0, 1, 2, 3처럼 증가시키며 반복 수행한다.                                                                      |
| 깊이 증가와 재탐색  | 깊이 제한이 늘 때마다 이전 탐색 트리를 버리고 다시 탐색하지만 실무적으로 과도한 오버헤드는 크지 않다.                                                  |
| IDS 내부 구조       | 각 반복은 DFS로 동작하므로 메모리 사용이 작다.                                                                                                         |
| IDS 확장 순서 예    | 예시는 깊이 제한을 0에서 3까지 늘리며 그때그때 가능한 범위 내 상태들을 확장한다.                                                                       |
| IDS 최종 해         | 예시의 최종 해는 A, H, L, M으로 깊이 증가 과정 중 발견된다.                                                                                            |
| IDS 완전성          | 너비 우선 탐색과 동일하게 항상 해를 보장한다.                                                                                                          |
| IDS 최적성          | 깊이 기준 최적 해를 보장하지만 비용 기준 최적성은 보장하지 않는다.                                                                                     |
| IDS 시간 복잡도     | 깊이 제한 l에 대해 시간 복잡도는 O(b^l)이며 반복으로 인한 추가 확장량은 보통 약간 증가한다.                                                            |
| IDS 오버헤드        | 분기계수 10, 제한 5의 예에서 반복적 깊이 증가는 단일 깊이 제한 탐색 대비 약 10% 정도 더 많은 노드를 확장한다.                                          |
| IDS 공간 복잡도     | DFS 기반이므로 공간 복잡도는 O(b^l)로 낮게 유지된다.                                                                                                   |
| 기호 정의           | b는 분기계수, d는 해의 깊이, m은 최대 깊이, l은 깊이 제한 값을 의미한다.                                                                               |
| Informed 평가식     | 유정보 탐색은 f(n) = g(n) + h(n)으로 노드를 평가해 가장 작은 값을 우선 확장한다.                                                                       |
| g(n) 의미           | g(n)은 초기 상태부터 현재 노드 n까지의 누적 실제 비용을 의미한다.                                                                                      |
| h(n) 의미           | h(n)은 현재 노드 n에서 목표까지의 남은 비용에 대한 휴리스틱 추정값을 의미한다.                                                                         |
| Uninformed 대비     | 무정보 탐색은 h(n)=0으로 간주하며, 유정보 탐색은 문제 지식을 반영한 h(n)을 사용한다.                                                                   |
| Greedy와 A\* 비교   | Greedy는 g(n)=0으로 h(n)만 사용하고, A\*는 g(n)과 h(n)을 모두 사용한다.                                                                                |
| h(n) 정의와 목적    | h(n)은 목표까지의 최저 비용을 추정해 유망한 노드를 먼저 확장하도록 돕는다.                                                                             |
| 지식 활용           | 실제 최단 거리는 알 수 없으므로 문제 도메인 지식을 활용해 합리적 추정치를 만든다.                                                                      |
| 과대평가 금지       | h(n)이 실제 비용을 초과하지 않도록 추정해야 A\*의 최적성이 보장된다.                                                                                   |
| 직선 거리 휴리스틱  | 경로 탐색에서 도시 간 직선 거리를 h(n)으로 사용하면 과대평가를 피하면서 유용한 가이드가 된다.                                                          |
| 직선 거리 예시      | 예시 그래프에서는 각 도시에서 목표 도시까지의 직선 거리 표를 휴리스틱으로 사용한다.                                                                    |
| Greedy 정의         | Greedy Best-first 탐색은 h(n)이 가장 작은 노드를 먼저 확장한다.                                                                                        |
| Greedy 적용 결과    | 예시에서 확장 순서는 A, H, L, M이 되어 빠르게 목표에 도달하지만 항상 최적 경로를 보장하진 않는다.                                                      |
| Greedy 완전성       | 중복 상태 제어가 없으면 완전성이 깨질 수 있다.                                                                                                         |
| Greedy 최적성       | 비용 기준 최적 해를 보장하지 않는다.                                                                                                                   |
| Greedy 시간 복잡도  | 최대 깊이가 m이면 시간 복잡도는 O(b^m)이다.                                                                                                            |
| Greedy 공간 복잡도  | 탐색 도중 다양한 노드를 저장해야 하므로 공간 복잡도는 O(b^m)이다.                                                                                      |
| A\* 정의            | A\* 탐색은 f(n)=g(n)+h(n)을 최소화하는 노드를 확장하여 경로 비용과 휴리스틱을 함께 고려한다.                                                           |
| A\* 적용 결과       | 예시에서 확장 순서는 A, H, I, K, L, M이며 최종 경로는 A, H, I, K, M으로 최적 비용을 달성한다.                                                          |
| A\* 완전성          | 적절한 조건에서 A\*는 항상 해를 찾는다.                                                                                                                |
| A\* 최적성 조건     | h(n)이 과대평가되지 않으면 A\*는 비용 기준 최적 경로를 보장한다.                                                                                       |
| A\* 시간 복잡도     | 최대 깊이가 m이면 시간 복잡도는 O(b^m)이며 많은 노드를 확장할 수 있다.                                                                                 |
| A\* 공간 복잡도     | 프린지와 방문 구조로 인해 공간 복잡도도 O(b^m)로 클 수 있다.                                                                                           |
| f 임계 특성         | 최적 경로 비용 이하의 f 값을 갖는 노드는 모두 확장되며, 이로써 최적성 보장이 성립한다.                                                                 |
| 8퍼즐 문제          | 8퍼즐은 퍼즐 타일을 이동해 목표 배치를 만드는 문제로, 휴리스틱 설계에 따라 탐색 성능이 크게 달라진다.                                                  |
| h1 정의             | h1은 목표 위치에 있지 않은 타일의 개수로, 단순하지만 구분력이 낮은 휴리스틱이다.                                                                       |
| h2 정의             | h2는 각 타일이 목표 위치로 이동하는 최소 이동 횟수의 합으로, 보통 맨해튼 거리 합을 사용해 더 정교하다.                                                 |
| h2 확장 해석        | h2를 사용할 때 g(n)은 지금까지의 공백 이동 횟수로 해석되며, f=g+h로 더 유망한 경로를 우선시한다.                                                       |
| h1 대비 h2 결과     | 동일 깊이에서 h2는 h1보다 확장 노드 수가 적어 탐색 효율이 더 높게 나타난다.                                                                            |
| 트리 탐색 요약      | 트리 탐색은 노드 확장 전략에 따라 다양한 기법이 가능하며 문제 구조에 맞는 전략 선택이 중요하다.                                                        |
| 성능 평가 요약      | 완전성, 최적성, 시간 복잡도, 공간 복잡도를 기준으로 알고리즘 성능을 비교한다.                                                                          |
| 탐색 분류 요약      | 탐색은 휴리스틱 사용 여부에 따라 무정보 탐색과 유정보 탐색으로 구분된다.                                                                               |
| 무정보 기법 요약    | BFS, DFS, DLS, IDS 등은 목표 깊이와 구조에 따라 장단점이 다르다.                                                                                       |
| A\* 핵심 요약       | A\*는                                                                                                                                                  |
