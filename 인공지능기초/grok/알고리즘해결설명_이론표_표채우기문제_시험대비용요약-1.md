알고리즘해결설명_이론표_표채우기문제_시험대비용요약.md

2025-10-19

인공지능 기초 과목에서 다루는 대표적인 탐색 문제(8-Puzzle, 8-Queens, 최단 경로, 순회 외판원, 배낭, 집합 커

버링)에 대해, 각 문제의 해결 과정에서 사용되는 연산자 시퀀스와 목적 함수의 수학적 모델링, 그리고 이를

uninformed search와 informed search 알고리즘으로 해결하는 이론을 초심자에게 설명하겠습니다. 또한, 요청

하신 대로 이론을 표로 정리하고, 타부 서치(Tabu Search)와 관련된 표 채우기 문제를 포함한 시험 대비용 요약

을 제공하겠습니다.

탐색 문제 해결을 위한 이론적 접근

탐색을 통한 문제 해결은 초기 상태에서 목표 상태로 도달하기 위한 일련의 연산자 시퀀스를 찾는 과정 또는 목

표 상태 자체를 찾는 과정으로 정의됩니다. 이를 위해 문제를 형식화하고, 상태 공간, 연산자, 목적 함수, 제약 조

건을 명확히 정의해야 합니다.

1. 탐색 문제의 구성 요소

상태 공간(State Space): 문제의 모든 가능한 상태(노드) 집합.

초기 상태(Initial State): 탐색이 시작되는 상태.

목표 상태(Goal State): 도달하고자 하는 상태(명시적 또는 제약 조건으로 정의).

연산자(Operators): 한 상태에서 다른 상태로 이동시키는 행동.

목적 함수(Objective Function): 최적화 목표(최소화: 비용 함수, 최대화: 이득 함수).

제약 조건(Constraints): 허용 가능한 상태나 이동을 제한하는 규칙.

2. 탐색 알고리즘 분류

Uninformed Search (Blind Search): 목표 상태까지의 정보를 사용하지 않고, 초기 상태부터의 경로 정

보만 활용.

예: Breadth-First Search (BFS), Depth-First Search (DFS), Uniform Cost Search (UCS), Depth-

Limited Search, Iterative Deepening Search.

Informed Search (Heuristic Search): 목표 상태까지의 추정 정보(휴리스틱)를 활용해 탐색 효율성을 높

임.

예: Greedy Best-First Search, A* Search.

3. 각 탐색 문제의 이론적 해결 과정

아래는 각 문제의 수학적 모델링과 해결 과정입니다.

(1) 8-Puzzle 문제

문제 정의: 3x3 격자에서 타일을 이동해 초기 상태에서 목표 상태(예: 1-2-3/4-5-6/7-8-공백)로 이동.

상태 공간: 9! / 2 = 181,440 (절반은 불가능한 상태).

연산자: 공백 타일을 동, 서, 남, 북으로 이동 (최대 4개).

목적 함수: 이동 횟수 최소화 (비용 함수: 이동 1회당 비용 1).

제약 조건: 타일은 격자 밖으로 이동 불가, 패리티 제약(역전 쌍 수로 해결 가능 여부 판단).

해결 과정:

Uninformed Search: BFS로 최단 경로 보장. 큐로 fringe 관리, 방문 상태 해시로 중복 방지.

시간/공간 복잡도: O(b^d), b≈3, d=해의 깊이.

Informed Search: A* with h(n) = Manhattan 거리(각 타일의 목표 위치까지의 거리 합). f(n) = g(n)

+ h(n), g(n)=이동 횟수.

1 / 6

알고리즘해결설명_이론표_표채우기문제_시험대비용요약.md

2025-10-19

예: 초기 상태 [1,5,4/3,2,7/8,6,공백] → h(n) = (5가 2행1열로 2칸, 3이 1행3열로 2칸, ...) = 7.

시간 복잡도: O(b^m), m=최대 깊이, 휴리스틱으로 효율성 개선.

(2) 8-Queens 문제

문제 정의: 8x8 체스판에 8개 퀸을 배치하되, 가로/세로/대각선 충돌 없음.

상태 공간: 순열 모델 기준 8! = 40,320.

연산자: 순열 모델에서 퀸의 행 위치 이동 또는 두 퀸의 행 교환.

목적 함수: 충돌 쌍 수 최소화 (0이 목표).

제약 조건: 각 열/행에 퀸 1개, 대각선 충돌 없음 (|xi - xj| ≠ |i - j|).

해결 과정:

Uninformed Search: DFS with backtracking. 각 행에 퀸 배치 후 제약 위반 시 가지치기.

시간 복잡도: O(b^m), b=8, m=8.

Informed Search: Hill-Climbing 또는 Genetic Algorithm. 휴리스틱: 충돌 쌍 수.

예: 초기 해 [3,1,7,4,8,2,6,5] → 충돌 쌍 계산 → 행 교환으로 충돌 감소.

로컬 최적 문제 주의.

(3) 최단 경로 문제

문제 정의: 그래프에서 시작 노드에서 목표 노드까지 최소 비용 경로 찾기.

상태 공간: 그래프 G=(V,E), 경우의 수 2^|V|.

연산자: 인접 노드로 이동.

목적 함수: 경로 비용 합 최소화.

제약 조건: 양의 비용, 사이클 없음.

해결 과정:

Uninformed Search: BFS (비가중), UCS (가중, 최적해 보장).

시간/공간 복잡도: O(b^d).

Informed Search: A* with h(n) = 직선 거리 (Euclidean). f(n) = g(n) + h(n).

예: 도시 A에서 M까지, h(n)=M까지 직선 거리(과소추정), g(n)=실제 이동 거리.

(4) 순회 외판원 문제 (TSP)

문제 정의: n개 도시를 한 번씩 방문하고 시작 도시로 돌아오는 최소 비용 경로.

상태 공간: (n-1)!/2 (대칭성).

연산자: 다음 도시 추가.

목적 함수: 경로 비용 합 최소화.

제약 조건: 모든 도시 방문, 서브투어 방지.

해결 과정:

Uninformed Search: DFS with branch-and-bound. 하한 비용으로 가지치기.

시간 복잡도: O(b^m).

Informed Search: A* with MST 휴리스틱 (남은 도시의 최소 신장 트리 비용).

예: 4개 도시, 초기 경로 [1,2] → MST로 남은 도시 비용 추정.

(5) 배낭 문제

문제 정의: 용량 W 내에서 가치 합 최대화.

상태 공간: 2^n (아이템 포함/제외).

연산자: 아이템 추가/제외.

2 / 6

알고리즘해결설명_이론표_표채우기문제_시험대비용요약.md

2025-10-19

목적 함수: 가치 합 최대화.

제약 조건: 무게 합 ≤ W.

해결 과정:

Uninformed Search: BFS로 모든 조합 탐색.

시간 복잡도: O(2^n).

Informed Search: Greedy (가치/무게 비율)로 근사 해. A* with 휴리스틱 (예: 남은 용량당 최대 가

치 추정).

예: W=10, 아이템 [(v=60,w=10), (v=100,w=20)] → Greedy 선택.

(6) 집합 커버링 문제

문제 정의: 최소 비용으로 모든 행을 커버하는 열 집합 선택.

상태 공간: 2^n (열 선택 조합).

연산자: 열 추가.

목적 함수: 선택된 열의 비용 합 최소화.

제약 조건: 모든 행 커버.

해결 과정:

Uninformed Search: BFS or DFS.

시간 복잡도: O(2^n).

Informed Search: Greedy (가장 많은 행 커버하는 열 선택). A* with 휴리스틱 (남은 행 수 / 최대

커버 가능 행).

예: 0-1 행렬에서 열 선택 → Greedy로 효율적 근사.

탐색 알고리즘 이론과 성능 평가

탐색 알고리즘은 트리 탐색 방식으로 문제를 해결하며, 노드 확장 전략에 따라 성능이 달라집니다. 아래는 주요

알고리즘의 이론적 작동 원리와 성능을 표로 정리한 것입니다.

Uninformed Search

Breadth-First Search (BFS): 큐로 fringe 관리, 깊이 낮은 노드부터 확장.

작동 원리: 모든 가능한 경로를 동일 깊이에서 탐색, 목표 상태 발견 시 종료.

장점: 최단 깊이 해 보장.

단점: 메모리 사용량 많음.

Uniform Cost Search (UCS): 비용 낮은 노드 우선 확장 (우선순위 큐).

작동 원리: g(n) = 초기 상태부터의 비용 기준 정렬.

장점: 비용 기준 최적해 보장.

Depth-First Search (DFS): 스택으로 깊이 우선 탐색.

작동 원리: 한 경로 끝까지 탐색 후 백트래킹.

단점: 무한 루프 가능, 최적해 보장 X.

Depth-Limited Search: DFS에 깊이 제한 추가.

작동 원리: 제한 깊이 내에서만 탐색.

장점: 메모리 효율적.

Iterative Deepening Search: 깊이 제한을 점진적으로 늘림.

작동 원리: DFS 반복, 깊이 0, 1, 2, ...로 증가.

장점: BFS의 완전성과 DFS의 메모리 효율성 결합.

3 / 6

알고리즘해결설명_이론표_표채우기문제_시험대비용요약.md

2025-10-19

Informed Search

Greedy Best-First Search: h(n) = 목표까지 추정 비용 기준 확장.

작동 원리: 가장 유망한 노드 우선 탐색.

단점: 최적해 보장 X.

A Search*: f(n) = g(n) + h(n), g(n)=실제 비용, h(n)=휴리스틱.

작동 원리: 비용과 휴리스틱 합 최소화.

장점: h(n)이 과소추정(admissible)일 때 최적해 보장.

성능 평가 표

알고리즘

해 도출 여부

최적해 보장

시간 복잡

공간 복잡

도

도

특징

Breadth-First Search

Uniform Cost Search

O

O

깊이 기준 O

O(b^d)

O(b^d)

큐, 최단 깊이 해

비용 기준 O

O(b^d)

O(b^d)

우선순위 큐, 최

적해

스택, 메모리 효

율

Depth-First Search

X (무한 루프

가능)

Depth-Limited Search

O (제한 내)

X

X

O(b^m)

O(bm)

O(b^l)

O(bl)

깊이 제한

Iterative Deepening

Search

Greedy Best-First

Search

O

깊이 기준 O

O(b^d)

O(bd)

BFS+DFS 결합

O (제어 필요)

X

O(b^m)

O(b^m)

휴리스틱 우선

A Search*

O

O (admissible

h(n))

O(b^m)

O(b^m)

최적해, 효율적

b: 분기 계수 (branching factor).

d: 해가 있는 깊이.

m: 트리의 최대 깊이.

l: 깊이 제한.

타부 서치(Tabu Search) 이론과 표 채우기

타부 서치는 **로컬 서치(Local Search)**의 일종으로, 로컬 최적해를 피하기 위해 최근 탐색한 해를 금지(Tabu)

리스트에 저장하여 탐색을 제어합니다. 이는 주로 조합 최적화 문제(예: 8-Queens, TSP)에 적합합니다.

타부 서치 작동 원리

1. 초기 해 생성: 임의의 초기 해(예: 8-Queens의 초기 퀸 배치).

2. 이웃 해 생성: 현재 해에서 연산자(예: 퀸 위치 교환)로 이웃 해 생성.

3. 목적 함수 평가: 이웃 해의 비용(예: 충돌 쌍 수) 계산.

4. 타부 리스트 관리:

최근 방문한 해 또는 연산자를 타부 리스트에 추가.

타부 리스트는 고정 크기(FIFO로 오래된 항목 제거).

4 / 6

알고리즘해결설명_이론표_표채우기문제_시험대비용요약.md

2025-10-19

타부 항목은 일정 반복 동안 선택 금지.

5. 최적 이웃 선택: 타부 아닌 이웃 중 목적 함수 값이 가장 좋은 해 선택.

6. Aspiration Criteria: 타부 항목이라도 현재 최적해보다 나으면 선택 가능.

7. 종료 조건: 최대 반복 횟수, 목표 비용 도달 등.

타부 서치 표 채우기 (시험 대비)

시험에서 자주 나오는 타부 서치 관련 표는 알고리즘 비교 또는 탐색 과정 추적 형식입니다. 아래는 예시입니다.

예시 문제: 타부 서치로 8-Queens 문제 해결

초기 해: [3,1,7,4,8,2,6,5], 비용(충돌 쌍 수)=3.

연산자: 두 퀸의 행 위치 교환.

타부 리스트 크기: 2.

이웃 해: [1,3,7,4,8,2,6,5], [3,7,1,4,8,2,6,5], ...

목표: 충돌 쌍 수 = 0.

단

계

1

2

3

현재 해

비

용

[3,1,7,4,8,2,6,5]

3

[3,7,1,4,8,2,6,5]

1

[7,3,1,4,8,2,6,5]

2

이웃 해들 (비용)

선택된 해

타부 리

스트

비고

1,3,7,4,8,2,6,5,

3,7,1,4,8,2,6,5

7,3,1,4,8,2,6,5,

3,1,7,4,8,2,6,5

3,7,1,4,8,2,6,5,

7,1,3,4,8,2,6,5

[3,7,1,4,8,2,6,5]

[(3,1)]

비용 1 선택

[7,3,1,4,8,2,6,5]

[7,1,3,4,8,2,6,5]

[(3,1),

(3,7)]

[(3,7),

(7,3)]

(3,1) 타부, 비용 2

선택

비용 0 달성, 종료

충돌 쌍 계산: 예: [3,1,7,4,8,2,6,5] → 대각선 충돌 (3,1), (7,4), (8,5) = 3쌍.

타부 리스트: 교환된 위치 쌍 (예: (3,1))을 기록, 재교환 방지.

시험용 암기 포인트

타부 서치 특징:

로컬 최적 탈출: 타부 리스트로 최근 해 금지.

유연성: Aspiration Criteria로 타부 무시 가능.

메모리 기반: 단기/장기 메모리 활용.

장점: Hill-Climbing보다 로컬 최적 회피 우수.

단점: 타부 리스트 크기 설정, 계산 비용 증가.

적용 문제: 8-Queens, TSP, 배낭 문제 등.

시험 대비 요약 (객관식/주관식/T-F 대비)

객관식 예시

1. 8-Puzzle에서 A 알고리즘의 휴리스틱으로 적합한 것은?*

(A) Manhattan 거리 (O)

5 / 6

알고리즘해결설명_이론표_표채우기문제_시험대비용요약.md

2025-10-19

(B) 타일 개수 (O, but less effective)

(C) 무작위 값 (X)

(D) 경로 비용 (X)

2. 타부 서치의 주요 특징은?

(A) 최근 방문 해를 금지 (O)

(B) 최적해 보장 (X)

(C) BFS 기반 (X)

(D) 무작위 탐색 (X)

주관식 예시

8-Queens 문제의 순열 기반 모델을 설명하시오.

답: 각 열에 퀸 1개를 배치, 결정 변수 xi는 i열의 행 위치 (1~8). 제약 조건은 각 행에 퀸 1개, 대각선

충돌 없음 (|xi - xj| ≠ |i - j|). 목적 함수는 충돌 쌍 수 최소화(0). 연산자는 퀸의 행 이동 또는 두 퀸의

행 교환.

타부 서치의 작동 원리를 설명하시오.

답: 초기 해에서 이웃 해 생성, 목적 함수로 평가. 타부 리스트로 최근 연산자/해 금지, 최적 이웃 선

택. Aspiration Criteria로 타부 무시 가능. 반복하며 최적 해 탐색.

T/F 문제 예시

1. BFS는 최적해를 보장한다. (T, 깊이 기준)
2. A Search는 h(n)이 과대추정 시 최적해를 보장한다.* (F, admissible 필요)
3. 타부 서치는 로컬 최적을 완전히 피할 수 있다. (F, 개선 가능하나 완전 피하기 어려움)

초심자를 위한 학습 팁

1. 문제 정의 연습: 각 문제의 상태 공간, 연산자, 목적 함수, 제약 조건을 명확히 정리.

2. 알고리즘 비교 암기: 위 표로 uninformed/informed 알고리즘의 성능(완전성, 최적성, 복잡도) 비교.

3. 타부 서치 시뮬레이션: 8-Queens 같은 간단한 문제로 표 채우기 연습.

4. 휴리스틱 설계: 8-Puzzle(Manhattan 거리), 최단 경로(직선 거리) 등 문제별 휴리스틱 이해.

5. 작은 예제 풀이: 4-Queens, 3도시 TSP 등으로 손으로 탐색 트리 그려보기.

이 표와 설명을 바탕으로 시험 준비하시면 객관식, 주관식, T/F 문제에 대비할 수 있습니다. 추가로 특정 문제나

알고리즘에 대해 더 깊이 알고 싶으시면 말씀해주세요!

6 / 6

